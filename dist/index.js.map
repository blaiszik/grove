{"version":3,"sources":["../src/index.ts","../src/commands/init.ts","../src/lib/config.ts","../src/types.ts","../src/lib/git.ts","../src/lib/deps.ts","../src/lib/framework.ts","../src/lib/output.ts","../src/commands/plant.ts","../src/lib/symlink.ts","../src/lib/editor.ts","../src/commands/list.ts","../src/lib/preview.ts","../src/commands/tend.ts","../src/commands/uproot.ts","../src/commands/preview.ts","../src/commands/status.ts","../src/commands/open.ts","../src/commands/spawn.ts","../src/commands/path.ts","../src/commands/ai.ts","../src/commands/adopt.ts","../src/commands/prune.ts","../src/commands/doctor.ts","../src/commands/claude.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { program } from 'commander';\nimport { init } from './commands/init.js';\nimport { plant } from './commands/plant.js';\nimport { list } from './commands/list.js';\nimport { tend } from './commands/tend.js';\nimport { uproot } from './commands/uproot.js';\nimport { preview } from './commands/preview.js';\nimport { status } from './commands/status.js';\nimport { open } from './commands/open.js';\nimport { spawn } from './commands/spawn.js';\nimport { getPath } from './commands/path.js';\nimport { ai } from './commands/ai.js';\nimport { adopt } from './commands/adopt.js';\nimport { prune } from './commands/prune.js';\nimport { doctor } from './commands/doctor.js';\nimport { claudeSetup } from './commands/claude.js';\n\nprogram\n  .name('grove')\n  .description('Git worktree manager with smart dependency handling')\n  .version('1.0.0')\n  .option('--json', 'Output machine-readable JSON')\n  .option('-q, --quiet', 'Suppress non-essential output');\n\nprogram\n  .command('init')\n  .description('Initialize grove in current repository')\n  .action(init);\n\nprogram\n  .command('plant <branch> [name]')\n  .description('Create a new worktree (plant a tree)')\n  .option('-n, --new', 'Create a new branch')\n  .option('-b, --base <branch>', 'Base branch for new branch')\n  .option('--no-install', 'Skip dependency installation')\n  .option('-s, --switch', 'Switch to the new tree after creating')\n  .action(plant);\n\nprogram\n  .command('tend <name>')\n  .description('Switch to a worktree (tend to a tree)')\n  .action(tend);\n\nprogram\n  .command('list')\n  .alias('ls')\n  .description('List all trees in the grove')\n  .action(list);\n\nprogram\n  .command('uproot <name>')\n  .description('Remove a worktree')\n  .option('-f, --force', 'Force removal even with uncommitted changes')\n  .action(uproot);\n\n// AI Coding Tool Integration\nprogram\n  .command('open <name>')\n  .description('Open a worktree in Cursor, VS Code, or other editor')\n  .option('-e, --editor <editor>', 'Specify editor (cursor, code, zed)')\n  .action(open);\n\nprogram\n  .command('spawn <name>')\n  .description('Start an interactive Claude Code session in a worktree')\n  .action(spawn);\n\nprogram\n  .command('ai <tool> <name> [args...]')\n  .description('Start an AI coding session in a worktree (tool: claude, codex, run)')\n  .allowUnknownOption(true)\n  .action(ai);\n\nprogram\n  .command('path <name>')\n  .description('Print the path to a worktree (for shell integration)')\n  .action(getPath);\n\nprogram\n  .command('adopt <path> [name]')\n  .description('Adopt an existing git worktree into grove')\n  .option('-s, --switch', 'Switch to the adopted tree after adopting')\n  .action(adopt);\n\nprogram\n  .command('prune')\n  .description('Remove stale grove config entries for missing worktrees')\n  .option('--dry-run', 'Show what would be pruned without changing config')\n  .action(prune);\n\nprogram\n  .command('doctor')\n  .description('Check grove health and optionally repair')\n  .option('--fix', 'Attempt to repair common issues')\n  .action(doctor);\n\nprogram\n  .command('claude')\n  .description('Claude Code integration helpers')\n  .command('setup')\n  .description('Scaffold Grove Claude skill and safe permissions')\n  .option('--dry-run', 'Show what would be created without writing')\n  .option('--force', 'Overwrite skill file if it already exists')\n  .option('--no-settings', 'Do not create .claude/settings.local.json')\n  .action(claudeSetup);\n\n// Preview & Status\nprogram\n  .command('preview <action> [names...]')\n  .description('Start/stop preview server (action: tree name(s), \"all\", or \"stop\")')\n  .option('-d, --dev', 'Run in development mode (default)')\n  .option('-b, --build', 'Build and serve in production mode')\n  .option('--port <port>', 'Use a specific port (single-tree only)', (v) => parseInt(v, 10))\n  .option('--all', 'Start previews for all trees')\n  .action(preview);\n\nprogram\n  .command('status')\n  .description('Show grove status and running previews')\n  .action(status);\n\n// Add some helpful examples\nprogram.addHelpText('after', `\n\nExamples:\n  $ grove init                    Initialize grove in current repo\n  $ grove plant feature-x         Create worktree for existing branch\n  $ grove plant -n my-feature     Create worktree with new branch\n\n  AI Coding Workflows:\n  $ grove open feature-x          Open in Cursor (or VS Code)\n  $ grove spawn feature-x         Start Claude Code in worktree\n  $ cd $(grove path feature-x)    Navigate to worktree in shell\n\n  Management:\n  $ grove list                    List all trees\n  $ grove tend feature-x          Switch current symlink\n  $ grove preview feature-x       Start dev server\n  $ grove uproot feature-x        Remove worktree\n\nThe 'current' symlink always points to the active tree.\n\nShell Integration:\n  Add to your .zshrc or .bashrc:\n\n  # Quick cd to grove tree\n  gcd() { cd \"$(grove path \"$1\")\"; }\n`);\n\nprogram.parse();\n","import fs from 'fs-extra';\nimport path from 'path';\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport {\n  getGroveDir,\n  getTreesDir,\n  getSharedDir,\n  groveExists,\n  writeConfig,\n  createDefaultConfig,\n} from '../lib/config.js';\nimport { isGitRepo, getRepoRoot, getCurrentBranch, createWorktree } from '../lib/git.js';\nimport { detectPackageManager } from '../lib/deps.js';\nimport { detectFramework } from '../lib/framework.js';\nimport { createCurrentLink } from '../lib/symlink.js';\nimport { GROVE_DIR } from '../types.js';\nimport { getOutputOptions, shouldUseSpinner, printJson } from '../lib/output.js';\n\nexport async function init(): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n\n  // Check if already initialized\n  if (await groveExists(cwd)) {\n    if (out.json) {\n      printJson({ ok: true, alreadyInitialized: true });\n      return;\n    }\n    if (!out.quiet) {\n      console.log(chalk.yellow('Grove is already initialized in this directory.'));\n    }\n    return;\n  }\n\n  // Check if in a git repo\n  if (!(await isGitRepo(cwd))) {\n    if (out.json) {\n      printJson({ ok: false, error: 'Not a git repository.' });\n    } else {\n      console.log(chalk.red('Error: Not a git repository.'));\n      console.log(chalk.gray('Run this command from within a git repository.'));\n    }\n    process.exit(1);\n  }\n\n  const spinner = shouldUseSpinner(out) ? ora('Initializing grove...').start() : null;\n\n  try {\n    const repoRoot = await getRepoRoot(cwd);\n    const currentBranch = await getCurrentBranch(cwd);\n    const groveRoot = repoRoot;\n\n    // Create directory structure\n    const groveDir = getGroveDir(groveRoot);\n    const treesDir = getTreesDir(groveRoot);\n    const sharedDir = getSharedDir(groveRoot);\n\n    await fs.ensureDir(groveDir);\n    await fs.ensureDir(treesDir);\n    await fs.ensureDir(sharedDir);\n\n    // Detect project configuration\n    if (spinner) spinner.text = 'Detecting project configuration...';\n    const packageManager = await detectPackageManager(cwd);\n    const framework = await detectFramework(cwd);\n\n    // Create initial config\n    const config = createDefaultConfig(repoRoot);\n    config.packageManager = packageManager;\n    config.framework = framework;\n\n    // Register the main repo directory as the \"main\" tree\n    // We don't create a worktree here because the current branch is already checked out\n    // in the main repo. Users can create worktrees for other branches with `grove plant`.\n    const mainTreeName = 'main';\n    config.trees[mainTreeName] = {\n      branch: currentBranch,\n      path: repoRoot, // Point to the actual repo, not a worktree\n      created: new Date().toISOString(),\n    };\n    config.current = mainTreeName;\n\n    // Save config\n    await writeConfig(config, groveRoot);\n\n    // Create current symlink pointing to the repo root\n    // Using relative path for the symlink\n    const currentLinkPath = path.join(groveRoot, 'current');\n    if (await fs.pathExists(currentLinkPath)) {\n      await fs.remove(currentLinkPath);\n    }\n    await fs.symlink('.', currentLinkPath);\n\n    // Add .grove to .gitignore if not already present\n    const gitignorePath = path.join(groveRoot, '.gitignore');\n    if (await fs.pathExists(gitignorePath)) {\n      const gitignore = await fs.readFile(gitignorePath, 'utf-8');\n      if (!gitignore.includes(GROVE_DIR)) {\n        await fs.appendFile(gitignorePath, `\\n# Grove worktree manager\\n${GROVE_DIR}/\\ncurrent\\n`);\n      }\n    } else {\n      await fs.writeFile(gitignorePath, `# Grove worktree manager\\n${GROVE_DIR}/\\ncurrent\\n`);\n    }\n\n    if (spinner) spinner.succeed('Grove initialized!');\n\n    if (out.json) {\n      printJson({\n        ok: true,\n        repo: repoRoot,\n        groveDir,\n        treesDir,\n        sharedDir,\n        packageManager,\n        framework,\n        current: mainTreeName,\n      });\n      return;\n    }\n\n    if (!out.quiet) {\n      console.log('');\n      console.log(chalk.green('Created:'));\n      console.log(chalk.gray(`  ${GROVE_DIR}/              Configuration directory`));\n      console.log(chalk.gray(`  ${GROVE_DIR}/trees/        Worktree storage`));\n      console.log(chalk.gray(`  current              Symlink to active tree`));\n      console.log('');\n      console.log(chalk.blue('Detected:'));\n      console.log(chalk.gray(`  Package manager: ${packageManager}`));\n      console.log(chalk.gray(`  Framework: ${framework}`));\n      console.log('');\n      console.log(chalk.cyan('Next steps:'));\n      console.log(chalk.gray(`  grove plant <branch>     Create a new worktree`));\n      console.log(chalk.gray(`  grove list               List all trees`));\n      console.log(chalk.gray(`  grove tend <name>        Switch to a tree`));\n    }\n  } catch (error) {\n    if (spinner) spinner.fail('Failed to initialize grove');\n    if (out.json) {\n      printJson({ ok: false, error: error instanceof Error ? error.message : String(error) });\n    } else {\n      console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    }\n    process.exit(1);\n  }\n}\n","import fs from 'fs-extra';\nimport path from 'path';\nimport { execa } from 'execa';\nimport {\n  GroveConfig,\n  GROVE_DIR,\n  GROVE_CONFIG,\n  GROVE_TREES,\n  GROVE_SHARED,\n} from '../types.js';\n\n/**\n * Find the grove root (directory containing .grove/config.json) starting from cwd.\n * Returns null if not found.\n */\nexport async function findGroveRoot(cwd: string = process.cwd()): Promise<string | null> {\n  let dir = path.resolve(cwd);\n\n  // Walk up looking for .grove/config.json\n  while (true) {\n    const candidate = path.join(dir, GROVE_DIR, GROVE_CONFIG);\n    if (await fs.pathExists(candidate)) {\n      return dir;\n    }\n\n    const parent = path.dirname(dir);\n    if (parent === dir) break;\n    dir = parent;\n  }\n\n  // Fallback: if inside a git repo/worktree, derive from git common dir\n  try {\n    const { stdout } = await execa('git', ['rev-parse', '--git-common-dir'], { cwd });\n    const commonDir = stdout.trim();\n    const commonAbs = path.isAbsolute(commonDir) ? commonDir : path.resolve(cwd, commonDir);\n    const commonParent = path.dirname(commonAbs);\n    const candidate = path.join(commonParent, GROVE_DIR, GROVE_CONFIG);\n    if (await fs.pathExists(candidate)) {\n      return commonParent;\n    }\n  } catch {\n    // Not a git repo or git unavailable\n  }\n\n  return null;\n}\n\n/**\n * Resolve grove root or throw a standard error.\n */\nexport async function resolveGroveRoot(cwd: string = process.cwd()): Promise<string> {\n  const root = await findGroveRoot(cwd);\n  if (!root) {\n    throw new Error('Grove not initialized. Run `grove init` first.');\n  }\n  return root;\n}\n\n/**\n * Throw if a tree name could escape grove boundaries or create unsafe paths.\n */\nexport function assertValidTreeName(name: string): void {\n  if (!name || name.trim() !== name) {\n    throw new Error(`Invalid tree name '${name}'.`);\n  }\n  if (name === '.' || name === '..') {\n    throw new Error(`Invalid tree name '${name}'.`);\n  }\n  if (name.includes('/') || name.includes('\\\\')) {\n    throw new Error(`Invalid tree name '${name}': path separators are not allowed.`);\n  }\n  if (!/^[A-Za-z0-9._-]+$/.test(name)) {\n    throw new Error(\n      `Invalid tree name '${name}': only letters, numbers, '.', '_' and '-' are allowed.`\n    );\n  }\n}\n\nexport function getGroveDir(cwd: string = process.cwd()): string {\n  return path.join(cwd, GROVE_DIR);\n}\n\nexport function getConfigPath(cwd: string = process.cwd()): string {\n  return path.join(getGroveDir(cwd), GROVE_CONFIG);\n}\n\nexport function getTreesDir(cwd: string = process.cwd()): string {\n  return path.join(getGroveDir(cwd), GROVE_TREES);\n}\n\nexport function getSharedDir(cwd: string = process.cwd()): string {\n  return path.join(getGroveDir(cwd), GROVE_SHARED);\n}\n\nexport function getTreePath(name: string, cwd: string = process.cwd()): string {\n  return path.join(getTreesDir(cwd), name);\n}\n\nexport async function groveExists(cwd: string = process.cwd()): Promise<boolean> {\n  const root = await findGroveRoot(cwd);\n  return root ? fs.pathExists(getConfigPath(root)) : false;\n}\n\nexport async function readConfig(cwd: string = process.cwd()): Promise<GroveConfig> {\n  const root = await resolveGroveRoot(cwd);\n  const configPath = getConfigPath(root);\n  if (!(await fs.pathExists(configPath))) {\n    throw new Error('Grove not initialized. Run `grove init` first.');\n  }\n  return fs.readJson(configPath);\n}\n\nexport async function writeConfig(\n  config: GroveConfig,\n  cwd: string = process.cwd()\n): Promise<void> {\n  const configPath = getConfigPath(cwd);\n  await fs.writeJson(configPath, config, { spaces: 2 });\n}\n\nexport async function updateConfig(\n  updater: (config: GroveConfig) => GroveConfig | Promise<GroveConfig>,\n  cwd: string = process.cwd()\n): Promise<GroveConfig> {\n  const root = await resolveGroveRoot(cwd);\n  const config = await readConfig(root);\n  const updated = await updater(config);\n  await writeConfig(updated, root);\n  return updated;\n}\n\nexport function createDefaultConfig(repo: string): GroveConfig {\n  return {\n    version: 1,\n    repo,\n    packageManager: 'npm',\n    framework: 'generic',\n    trees: {},\n    current: null,\n    previews: {},\n  };\n}\n","export type PackageManager = 'pnpm' | 'npm' | 'yarn';\nexport type Framework = 'nextjs' | 'vite' | 'cra' | 'generic';\n\nexport interface TreeInfo {\n  branch: string;\n  path: string;\n  created: string;\n}\n\nexport interface PreviewInfo {\n  pid: number;\n  port: number;\n  mode: 'dev' | 'build';\n  startedAt: string;\n}\n\nexport interface GroveConfig {\n  version: 1;\n  repo: string;\n  packageManager: PackageManager;\n  framework: Framework;\n  trees: Record<string, TreeInfo>;\n  current: string | null;\n  previews: Record<string, PreviewInfo>;\n}\n\nexport interface DetectedProject {\n  packageManager: PackageManager;\n  framework: Framework;\n  hasPackageJson: boolean;\n  lockfile: string | null;\n}\n\nexport const GROVE_DIR = '.grove';\nexport const GROVE_CONFIG = 'config.json';\nexport const GROVE_TREES = 'trees';\nexport const GROVE_SHARED = 'shared';\nexport const CURRENT_LINK = 'current';\n","import { execa } from 'execa';\nimport path from 'path';\n\nexport interface GitWorktree {\n  path: string;\n  head: string;\n  branch: string | null;\n}\n\nexport async function isGitRepo(cwd: string = process.cwd()): Promise<boolean> {\n  try {\n    await execa('git', ['rev-parse', '--git-dir'], { cwd });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function getRepoRoot(cwd: string = process.cwd()): Promise<string> {\n  const { stdout } = await execa('git', ['rev-parse', '--show-toplevel'], { cwd });\n  return stdout.trim();\n}\n\nexport async function getCurrentBranch(cwd: string = process.cwd()): Promise<string> {\n  const { stdout } = await execa('git', ['rev-parse', '--abbrev-ref', 'HEAD'], { cwd });\n  return stdout.trim();\n}\n\nexport async function branchExists(branch: string, cwd: string = process.cwd()): Promise<boolean> {\n  try {\n    await execa('git', ['rev-parse', '--verify', branch], { cwd });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function remoteBranchExists(branch: string, cwd: string = process.cwd()): Promise<boolean> {\n  try {\n    await execa('git', ['rev-parse', '--verify', `origin/${branch}`], { cwd });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function createWorktree(\n  targetPath: string,\n  branch: string,\n  options: { createBranch?: boolean; baseBranch?: string } = {},\n  cwd: string = process.cwd()\n): Promise<void> {\n  const args = ['worktree', 'add'];\n\n  if (options.createBranch) {\n    args.push('-b', branch);\n    args.push(targetPath);\n    if (options.baseBranch) {\n      args.push(options.baseBranch);\n    }\n  } else {\n    args.push(targetPath, branch);\n  }\n\n  await execa('git', args, { cwd });\n}\n\nexport async function removeWorktree(\n  targetPath: string,\n  options: { force?: boolean } = {},\n  cwd: string = process.cwd()\n): Promise<void> {\n  const args = ['worktree', 'remove'];\n  if (options.force) {\n    args.push('--force');\n  }\n  args.push(targetPath);\n\n  await execa('git', args, { cwd });\n}\n\nexport async function listWorktrees(cwd: string = process.cwd()): Promise<GitWorktree[]> {\n  const { stdout } = await execa('git', ['worktree', 'list', '--porcelain'], { cwd });\n  const worktrees: GitWorktree[] = [];\n  let current: Partial<GitWorktree> = {};\n\n  for (const line of stdout.split('\\n')) {\n    if (line.startsWith('worktree ')) {\n      current.path = line.slice(9);\n    } else if (line.startsWith('HEAD ')) {\n      current.head = line.slice(5);\n    } else if (line.startsWith('branch ')) {\n      current.branch = line.slice(7).replace('refs/heads/', '');\n    } else if (line === 'detached') {\n      current.branch = null;\n    } else if (line === '') {\n      if (current.path && current.head !== undefined) {\n        worktrees.push(current as GitWorktree);\n      }\n      current = {};\n    }\n  }\n\n  // Handle last entry if no trailing newline\n  if (current.path && current.head !== undefined) {\n    worktrees.push(current as GitWorktree);\n  }\n\n  return worktrees;\n}\n\nexport async function fetchBranch(branch: string, cwd: string = process.cwd()): Promise<void> {\n  await execa('git', ['fetch', 'origin', branch], { cwd });\n}\n\nexport async function getGitDir(cwd: string = process.cwd()): Promise<string> {\n  const { stdout } = await execa('git', ['rev-parse', '--git-dir'], { cwd });\n  const gitDir = stdout.trim();\n  return path.isAbsolute(gitDir) ? gitDir : path.join(cwd, gitDir);\n}\n","import fs from 'fs-extra';\nimport path from 'path';\nimport { execa } from 'execa';\nimport crypto from 'crypto';\nimport { PackageManager } from '../types.js';\nimport { getSharedDir } from './config.js';\n\nexport interface LockfileInfo {\n  type: PackageManager;\n  path: string;\n  hash: string;\n}\n\nconst LOCKFILES: Record<string, PackageManager> = {\n  'pnpm-lock.yaml': 'pnpm',\n  'yarn.lock': 'yarn',\n  'package-lock.json': 'npm',\n};\n\nexport async function detectPackageManager(\n  cwd: string = process.cwd()\n): Promise<PackageManager> {\n  // Check for lockfiles in order of preference\n  for (const [filename, manager] of Object.entries(LOCKFILES)) {\n    if (await fs.pathExists(path.join(cwd, filename))) {\n      return manager;\n    }\n  }\n  return 'npm';\n}\n\nexport async function getLockfileInfo(\n  cwd: string = process.cwd()\n): Promise<LockfileInfo | null> {\n  for (const [filename, manager] of Object.entries(LOCKFILES)) {\n    const lockfilePath = path.join(cwd, filename);\n    if (await fs.pathExists(lockfilePath)) {\n      const content = await fs.readFile(lockfilePath);\n      const hash = crypto.createHash('sha256').update(content).digest('hex');\n      return { type: manager, path: lockfilePath, hash };\n    }\n  }\n  return null;\n}\n\nexport async function installDependencies(\n  manager: PackageManager,\n  targetDir: string,\n  options: { useSharedStore?: boolean; groveDir?: string } = {}\n): Promise<void> {\n  const args: string[] = ['install'];\n\n  if (manager === 'pnpm' && options.useSharedStore && options.groveDir) {\n    const storePath = path.join(getSharedDir(options.groveDir), 'pnpm-store');\n    await fs.ensureDir(storePath);\n    args.push('--store-dir', storePath);\n  }\n\n  // Add flags for cleaner output\n  if (manager === 'npm') {\n    args.push('--prefer-offline');\n  } else if (manager === 'yarn') {\n    args.push('--prefer-offline');\n  } else if (manager === 'pnpm') {\n    args.push('--prefer-offline');\n  }\n\n  await execa(manager, args, {\n    cwd: targetDir,\n    stdio: 'inherit',\n  });\n}\n\nexport async function canSymlinkNodeModules(\n  sourceDir: string,\n  targetDir: string\n): Promise<boolean> {\n  const sourceLockfile = await getLockfileInfo(sourceDir);\n  const targetLockfile = await getLockfileInfo(targetDir);\n\n  if (!sourceLockfile || !targetLockfile) {\n    return false;\n  }\n\n  // Can only symlink if same package manager and same lockfile hash\n  return (\n    sourceLockfile.type === targetLockfile.type &&\n    sourceLockfile.hash === targetLockfile.hash\n  );\n}\n\nexport async function symlinkNodeModules(\n  sourceDir: string,\n  targetDir: string\n): Promise<void> {\n  const sourceModules = path.join(sourceDir, 'node_modules');\n  const targetModules = path.join(targetDir, 'node_modules');\n\n  if (!(await fs.pathExists(sourceModules))) {\n    throw new Error(`Source node_modules not found: ${sourceModules}`);\n  }\n\n  // Remove existing node_modules in target if present\n  if (await fs.pathExists(targetModules)) {\n    await fs.remove(targetModules);\n  }\n\n  // Create relative symlink\n  const relativePath = path.relative(targetDir, sourceModules);\n  await fs.symlink(relativePath, targetModules);\n}\n\nexport async function copyLockfile(\n  sourceDir: string,\n  targetDir: string,\n  manager: PackageManager\n): Promise<void> {\n  const lockfileName = Object.entries(LOCKFILES).find(\n    ([, m]) => m === manager\n  )?.[0];\n\n  if (!lockfileName) return;\n\n  const sourcePath = path.join(sourceDir, lockfileName);\n  const targetPath = path.join(targetDir, lockfileName);\n\n  if (await fs.pathExists(sourcePath)) {\n    await fs.copy(sourcePath, targetPath);\n  }\n}\n\nexport async function hasNodeModules(dir: string): Promise<boolean> {\n  return fs.pathExists(path.join(dir, 'node_modules'));\n}\n","import fs from 'fs-extra';\nimport path from 'path';\nimport { Framework, PackageManager } from '../types.js';\n\ninterface FrameworkConfig {\n  devCommand: string;\n  buildCommand: string;\n  serveCommand: string;\n  defaultPort: number;\n  cacheDir: string | null;\n}\n\nexport const FRAMEWORK_CONFIGS: Record<Framework, FrameworkConfig> = {\n  nextjs: {\n    devCommand: 'next dev',\n    buildCommand: 'next build',\n    serveCommand: 'next start',\n    defaultPort: 3000,\n    cacheDir: '.next',\n  },\n  vite: {\n    devCommand: 'vite',\n    buildCommand: 'vite build',\n    serveCommand: 'vite preview',\n    defaultPort: 5173,\n    cacheDir: '.vite',\n  },\n  cra: {\n    devCommand: 'react-scripts start',\n    buildCommand: 'react-scripts build',\n    serveCommand: 'serve -s build',\n    defaultPort: 3000,\n    cacheDir: null,\n  },\n  generic: {\n    devCommand: 'npm run dev',\n    buildCommand: 'npm run build',\n    serveCommand: 'npm run start',\n    defaultPort: 3000,\n    cacheDir: null,\n  },\n};\n\nexport async function detectFramework(cwd: string = process.cwd()): Promise<Framework> {\n  const packageJsonPath = path.join(cwd, 'package.json');\n\n  if (!(await fs.pathExists(packageJsonPath))) {\n    return 'generic';\n  }\n\n  try {\n    const pkg = await fs.readJson(packageJsonPath);\n    const deps = {\n      ...pkg.dependencies,\n      ...pkg.devDependencies,\n    };\n\n    // Check for Next.js\n    if (deps.next) {\n      return 'nextjs';\n    }\n\n    // Check for Vite\n    if (deps.vite) {\n      return 'vite';\n    }\n\n    // Check for Create React App\n    if (deps['react-scripts']) {\n      return 'cra';\n    }\n\n    return 'generic';\n  } catch {\n    return 'generic';\n  }\n}\n\nexport function getFrameworkConfig(framework: Framework): FrameworkConfig {\n  return FRAMEWORK_CONFIGS[framework];\n}\n\nfunction runScript(manager: PackageManager, script: string): string {\n  if (manager === 'npm') {\n    return `npm run ${script}`;\n  }\n  return `${manager} ${script}`;\n}\n\nexport async function getDevCommand(\n  cwd: string = process.cwd(),\n  manager: PackageManager = 'npm'\n): Promise<string> {\n  const packageJsonPath = path.join(cwd, 'package.json');\n\n  if (await fs.pathExists(packageJsonPath)) {\n    try {\n      const pkg = await fs.readJson(packageJsonPath);\n      if (pkg.scripts?.dev) {\n        return runScript(manager, 'dev');\n      }\n      if (pkg.scripts?.start) {\n        return runScript(manager, 'start');\n      }\n    } catch {\n      // Fall through to framework detection\n    }\n  }\n\n  const framework = await detectFramework(cwd);\n  return FRAMEWORK_CONFIGS[framework].devCommand;\n}\n\nexport async function getBuildCommand(\n  cwd: string = process.cwd(),\n  manager: PackageManager = 'npm'\n): Promise<string> {\n  const packageJsonPath = path.join(cwd, 'package.json');\n\n  if (await fs.pathExists(packageJsonPath)) {\n    try {\n      const pkg = await fs.readJson(packageJsonPath);\n      if (pkg.scripts?.build) {\n        return runScript(manager, 'build');\n      }\n    } catch {\n      // Fall through to framework detection\n    }\n  }\n\n  const framework = await detectFramework(cwd);\n  return FRAMEWORK_CONFIGS[framework].buildCommand;\n}\n\nexport async function getServeCommand(\n  cwd: string = process.cwd(),\n  manager: PackageManager = 'npm'\n): Promise<string> {\n  const packageJsonPath = path.join(cwd, 'package.json');\n\n  if (await fs.pathExists(packageJsonPath)) {\n    try {\n      const pkg = await fs.readJson(packageJsonPath);\n      if (pkg.scripts?.start) {\n        return runScript(manager, 'start');\n      }\n      if (pkg.scripts?.serve) {\n        return runScript(manager, 'serve');\n      }\n    } catch {\n      // Fall through to framework detection\n    }\n  }\n\n  const framework = await detectFramework(cwd);\n  return FRAMEWORK_CONFIGS[framework].serveCommand;\n}\n\nexport async function clearFrameworkCache(\n  cwd: string,\n  framework: Framework\n): Promise<void> {\n  const config = FRAMEWORK_CONFIGS[framework];\n  if (config.cacheDir) {\n    const cachePath = path.join(cwd, config.cacheDir);\n    if (await fs.pathExists(cachePath)) {\n      await fs.remove(cachePath);\n    }\n  }\n}\n","export interface OutputOptions {\n  json: boolean;\n  quiet: boolean;\n}\n\nexport function getOutputOptions(argv: string[] = process.argv): OutputOptions {\n  const json = argv.includes('--json');\n  const quiet = argv.includes('--quiet') || argv.includes('-q');\n  return { json, quiet };\n}\n\nexport function shouldUseSpinner(opts: OutputOptions): boolean {\n  return !opts.json && !opts.quiet;\n}\n\nexport function printJson(value: unknown): void {\n  process.stdout.write(JSON.stringify(value, null, 2) + '\\n');\n}\n\n","import path from 'path';\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport { readConfig, updateConfig, getTreePath, getGroveDir, resolveGroveRoot, assertValidTreeName } from '../lib/config.js';\nimport {\n  branchExists,\n  remoteBranchExists,\n  createWorktree,\n  fetchBranch,\n} from '../lib/git.js';\nimport {\n  detectPackageManager,\n  installDependencies,\n  canSymlinkNodeModules,\n  symlinkNodeModules,\n  hasNodeModules,\n} from '../lib/deps.js';\nimport { createCurrentLink } from '../lib/symlink.js';\nimport { copyEditorConfigs } from '../lib/editor.js';\nimport { getOutputOptions, shouldUseSpinner, printJson } from '../lib/output.js';\n\ninterface PlantOptions {\n  new?: boolean;\n  base?: string;\n  install?: boolean;\n  switch?: boolean;\n}\n\nexport async function plant(\n  branch: string,\n  name: string | undefined,\n  options: PlantOptions\n): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n  const treeName = name || branch.replace(/\\//g, '-');\n\n  const spinner = shouldUseSpinner(out) ? ora(`Planting tree '${treeName}'...`).start() : null;\n\n  try {\n    assertValidTreeName(treeName);\n    const groveRoot = await resolveGroveRoot(cwd);\n    const config = await readConfig(groveRoot);\n\n    // Check if tree already exists\n    if (config.trees[treeName]) {\n      if (spinner) spinner.fail(`Tree '${treeName}' already exists`);\n      if (out.json) {\n        printJson({ ok: false, error: `Tree '${treeName}' already exists`, name: treeName });\n      } else if (!out.quiet) {\n        console.log(chalk.gray(`Use 'grove tend ${treeName}' to switch to it.`));\n      }\n      process.exit(1);\n    }\n\n    // Determine if we need to create a new branch\n    const localExists = await branchExists(branch, config.repo);\n    const remoteExists = await remoteBranchExists(branch, config.repo);\n    const shouldCreate = options.new || (!localExists && !remoteExists);\n\n    if (!localExists && remoteExists && !options.new) {\n      if (spinner) spinner.text = `Fetching branch '${branch}' from origin...`;\n      await fetchBranch(branch, config.repo);\n    }\n\n    // Create the worktree\n    if (spinner) spinner.text = `Creating worktree for '${branch}'...`;\n    const treePath = getTreePath(treeName, groveRoot);\n\n    await createWorktree(\n      treePath,\n      branch,\n      {\n        createBranch: shouldCreate,\n        baseBranch: options.base,\n      },\n      config.repo\n    );\n\n    // Copy editor/AI tool configurations from repo root\n    if (spinner) spinner.text = 'Copying editor configurations...';\n    const copiedConfigs = await copyEditorConfigs(config.repo, treePath);\n    if (copiedConfigs.length > 0) {\n      if (spinner) spinner.text = `Copied: ${copiedConfigs.join(', ')}`;\n    }\n\n    // Handle dependencies\n    const shouldInstall = options.install !== false; // Default to true\n    if (shouldInstall) {\n      if (spinner) spinner.text = 'Setting up dependencies...';\n\n      // Find an existing tree with node_modules\n      let sourceTree: string | null = null;\n      for (const [existingName, tree] of Object.entries(config.trees)) {\n        if (await hasNodeModules(tree.path)) {\n          sourceTree = existingName;\n          break;\n        }\n      }\n\n      const manager = await detectPackageManager(treePath);\n\n      if (manager === 'pnpm') {\n        // pnpm: always install with shared store\n        if (spinner) spinner.text = 'Installing dependencies with shared pnpm store...';\n        await installDependencies(manager, treePath, {\n          useSharedStore: true,\n          groveDir: groveRoot,\n        });\n      } else if (sourceTree) {\n        // npm/yarn: try to symlink if lockfiles match\n        const sourceTreePath = config.trees[sourceTree].path;\n        const canSymlink = await canSymlinkNodeModules(sourceTreePath, treePath);\n\n        if (canSymlink) {\n          if (spinner) spinner.text = `Symlinking node_modules from '${sourceTree}'...`;\n          await symlinkNodeModules(sourceTreePath, treePath);\n        } else {\n          if (spinner) spinner.text = 'Installing dependencies...';\n          await installDependencies(manager, treePath);\n        }\n      } else {\n        // No existing tree with node_modules, fresh install\n        if (spinner) spinner.text = 'Installing dependencies...';\n        await installDependencies(manager, treePath);\n      }\n    }\n\n    // Register the tree\n    const createdAt = new Date().toISOString();\n    await updateConfig((c) => ({\n      ...c,\n      trees: {\n        ...c.trees,\n        [treeName]: {\n          branch,\n          path: treePath,\n          created: createdAt,\n        },\n      },\n    }), cwd);\n\n    // Optionally switch to the new tree\n    if (options.switch) {\n      await createCurrentLink(treeName, cwd);\n      await updateConfig((c) => ({\n        ...c,\n        current: treeName,\n      }), cwd);\n    }\n\n    if (spinner) spinner.succeed(`Planted tree '${treeName}'`);\n\n    if (out.json) {\n      printJson({\n        ok: true,\n        tree: {\n          name: treeName,\n          branch,\n          path: treePath,\n          created: createdAt,\n        },\n        copiedConfigs,\n        switched: !!options.switch,\n      });\n      return;\n    }\n\n    if (out.quiet) {\n      return;\n    }\n\n    console.log('');\n    console.log(chalk.green('Tree details:'));\n    console.log(chalk.gray(`  Name:   ${treeName}`));\n    console.log(chalk.gray(`  Branch: ${branch}`));\n    console.log(chalk.gray(`  Path:   ${treePath}`));\n    console.log('');\n\n    if (copiedConfigs.length > 0) {\n      console.log(chalk.blue('Copied configs:'));\n      console.log(chalk.gray(`  ${copiedConfigs.join(', ')}`));\n      console.log('');\n    }\n\n    if (options.switch) {\n      console.log(chalk.cyan(`Switched to '${treeName}'`));\n    } else {\n      console.log(chalk.cyan('Next steps:'));\n      console.log(chalk.gray(`  grove open ${treeName}        Open in Cursor/VS Code`));\n      console.log(chalk.gray(`  grove spawn ${treeName}       Start Claude Code session`));\n      console.log(chalk.gray(`  grove tend ${treeName}        Switch current symlink`));\n    }\n  } catch (error) {\n    if (spinner) spinner.fail('Failed to plant tree');\n    const message = error instanceof Error ? error.message : String(error);\n    if (out.json) {\n      printJson({ ok: false, error: message });\n    } else {\n      console.error(chalk.red(message));\n    }\n    process.exit(1);\n  }\n}\n","import fs from 'fs-extra';\nimport path from 'path';\nimport { CURRENT_LINK } from '../types.js';\nimport { getTreePath, readConfig, findGroveRoot } from './config.js';\n\nasync function getGroveRootOrCwd(cwd: string): Promise<string> {\n  const root = await findGroveRoot(cwd);\n  return root ?? path.resolve(cwd);\n}\n\nexport function getCurrentLinkPath(cwd: string = process.cwd()): string {\n  return path.join(cwd, CURRENT_LINK);\n}\n\nexport async function createCurrentLink(\n  treeName: string,\n  cwd: string = process.cwd()\n): Promise<void> {\n  const groveRoot = await getGroveRootOrCwd(cwd);\n  const linkPath = getCurrentLinkPath(groveRoot);\n\n  let targetPath = getTreePath(treeName, groveRoot);\n  try {\n    const config = await readConfig(groveRoot);\n    const tree = config.trees[treeName];\n    if (tree) {\n      targetPath = tree.path;\n    }\n  } catch {\n    // Grove may not be initialized; fall back to computed tree path\n  }\n\n  // Remove existing symlink if present\n  if (await fs.pathExists(linkPath)) {\n    await fs.remove(linkPath);\n  }\n\n  // Create relative symlink\n  const relativePathRaw = path.relative(groveRoot, targetPath);\n  const relativePath = relativePathRaw || '.';\n  await fs.symlink(relativePath, linkPath);\n}\n\nexport async function removeCurrentLink(cwd: string = process.cwd()): Promise<void> {\n  const groveRoot = await getGroveRootOrCwd(cwd);\n  const linkPath = getCurrentLinkPath(groveRoot);\n  if (await fs.pathExists(linkPath)) {\n    await fs.remove(linkPath);\n  }\n}\n\nexport async function getCurrentTreeName(cwd: string = process.cwd()): Promise<string | null> {\n  const groveRoot = await getGroveRootOrCwd(cwd);\n  const linkPath = getCurrentLinkPath(groveRoot);\n\n  try {\n    const target = await fs.readlink(linkPath);\n\n    // Handle special case where symlink points to '.' (main repo)\n    if (target === '.') {\n      try {\n        // Find the tree that points to the repo root\n        const config = await readConfig(groveRoot);\n        for (const [name, tree] of Object.entries(config.trees)) {\n          // The main tree path is the repo root (cwd after normalization)\n          const normalizedTreePath = path.resolve(tree.path);\n          const normalizedCwd = path.resolve(groveRoot);\n          if (normalizedTreePath === normalizedCwd) {\n            return name;\n          }\n        }\n      } catch {\n        // No config; can't resolve main tree name\n      }\n      return null;\n    }\n\n    // Extract tree name from path like .grove/trees/main\n    const parts = target.split(path.sep);\n    return parts[parts.length - 1];\n  } catch {\n    return null;\n  }\n}\n\nexport async function isSymlinkValid(cwd: string = process.cwd()): Promise<boolean> {\n  const groveRoot = await getGroveRootOrCwd(cwd);\n  const linkPath = getCurrentLinkPath(groveRoot);\n\n  try {\n    const stat = await fs.lstat(linkPath);\n    if (!stat.isSymbolicLink()) {\n      return false;\n    }\n    // Check if target exists\n    await fs.stat(linkPath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { execa } from 'execa';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport { readConfig, resolveGroveRoot } from './config.js';\n\nexport type Editor = 'cursor' | 'code' | 'claude' | 'zed';\n\ninterface EditorConfig {\n  command: string;\n  args: string[];\n  name: string;\n}\n\nconst EDITORS: Record<Editor, EditorConfig> = {\n  cursor: {\n    command: 'cursor',\n    args: ['.'],\n    name: 'Cursor',\n  },\n  code: {\n    command: 'code',\n    args: ['.'],\n    name: 'VS Code',\n  },\n  claude: {\n    command: 'claude',\n    args: [],\n    name: 'Claude Code',\n  },\n  zed: {\n    command: 'zed',\n    args: ['.'],\n    name: 'Zed',\n  },\n};\n\nexport async function detectAvailableEditors(): Promise<Editor[]> {\n  const available: Editor[] = [];\n\n  for (const [name, config] of Object.entries(EDITORS)) {\n    try {\n      await execa('which', [config.command]);\n      available.push(name as Editor);\n    } catch {\n      // Editor not available\n    }\n  }\n\n  return available;\n}\n\nexport async function openInEditor(\n  treeName: string,\n  editor: Editor,\n  cwd: string = process.cwd()\n): Promise<void> {\n  const groveRoot = await resolveGroveRoot(cwd);\n  const configFile = await readConfig(groveRoot);\n  const tree = configFile.trees[treeName];\n  if (!tree) {\n    throw new Error(`Tree '${treeName}' not found`);\n  }\n  const treePath = tree.path;\n  const config = EDITORS[editor];\n\n  if (!config) {\n    throw new Error(`Unknown editor: ${editor}`);\n  }\n\n  // Verify tree exists\n  if (!(await fs.pathExists(treePath))) {\n    throw new Error(`Tree path does not exist: ${treePath}`);\n  }\n\n  // Launch editor in the worktree directory\n  await execa(config.command, config.args, {\n    cwd: treePath,\n    detached: true,\n    stdio: 'ignore',\n  });\n}\n\nexport async function spawnClaudeCode(\n  treeName: string,\n  cwd: string = process.cwd()\n): Promise<void> {\n  const groveRoot = await resolveGroveRoot(cwd);\n  const configFile = await readConfig(groveRoot);\n  const tree = configFile.trees[treeName];\n  if (!tree) {\n    throw new Error(`Tree '${treeName}' not found`);\n  }\n  const treePath = tree.path;\n\n  // Verify tree exists\n  if (!(await fs.pathExists(treePath))) {\n    throw new Error(`Tree path does not exist: ${treePath}`);\n  }\n\n  // Spawn Claude Code in a new session\n  // Using --yes to auto-accept any prompts\n  const child = execa('claude', [], {\n    cwd: treePath,\n    stdio: 'inherit',\n  });\n\n  // Wait for it to complete (interactive session)\n  await child;\n}\n\n// Files/directories to copy from the source repo to new worktrees\n// These are tool-specific configurations that should be preserved\nconst CONFIG_DIRS_TO_COPY = [\n  '.claude',           // Claude Code settings\n  '.cursor',           // Cursor settings\n  '.vscode',           // VS Code settings\n  '.zed',              // Zed settings\n  '.idea',             // JetBrains settings\n];\n\nconst CONFIG_FILES_TO_COPY = [\n  '.cursorrules',      // Cursor rules\n  '.clauderules',      // Claude rules (if exists)\n  'CLAUDE.md',         // Claude context file\n  'cursor.json',       // Cursor config\n];\n\nexport async function copyEditorConfigs(\n  sourceDir: string,\n  targetDir: string\n): Promise<string[]> {\n  const copied: string[] = [];\n\n  // Copy config directories\n  for (const dir of CONFIG_DIRS_TO_COPY) {\n    const sourcePath = path.join(sourceDir, dir);\n    const targetPath = path.join(targetDir, dir);\n\n    if (await fs.pathExists(sourcePath)) {\n      await fs.copy(sourcePath, targetPath, { overwrite: false });\n      copied.push(dir);\n    }\n  }\n\n  // Copy config files\n  for (const file of CONFIG_FILES_TO_COPY) {\n    const sourcePath = path.join(sourceDir, file);\n    const targetPath = path.join(targetDir, file);\n\n    if (await fs.pathExists(sourcePath)) {\n      await fs.copy(sourcePath, targetPath, { overwrite: false });\n      copied.push(file);\n    }\n  }\n\n  return copied;\n}\n\nexport function getEditorName(editor: Editor): string {\n  return EDITORS[editor]?.name || editor;\n}\n\nexport function getSupportedEditors(): Editor[] {\n  return Object.keys(EDITORS) as Editor[];\n}\n","import chalk from 'chalk';\nimport { readConfig } from '../lib/config.js';\nimport { getCurrentTreeName, isSymlinkValid } from '../lib/symlink.js';\nimport { isPreviewRunning, getRunningPreviews } from '../lib/preview.js';\nimport { getOutputOptions, printJson } from '../lib/output.js';\n\nexport async function list(): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n\n  try {\n    const config = await readConfig(cwd);\n    const currentTree = await getCurrentTreeName(cwd);\n    const previews = await getRunningPreviews(cwd);\n\n    const trees = Object.entries(config.trees);\n\n    if (trees.length === 0) {\n      if (out.json) {\n        printJson({\n          repo: config.repo,\n          packageManager: config.packageManager,\n          framework: config.framework,\n          current: currentTree,\n          trees: [],\n        });\n        return;\n      }\n      if (!out.quiet) {\n        console.log(chalk.yellow('No trees in the grove.'));\n        console.log(chalk.gray('Run `grove plant <branch>` to create one.'));\n      }\n      return;\n    }\n\n    if (out.json) {\n      const treesOut = await Promise.all(\n        trees.map(async ([name, info]) => {\n          const preview = previews[name];\n          const running = preview ? await isPreviewRunning(name, cwd) : false;\n          return {\n            name,\n            branch: info.branch,\n            path: info.path,\n            created: info.created,\n            current: name === currentTree,\n            preview: running && preview ? preview : null,\n          };\n        })\n      );\n\n      printJson({\n        repo: config.repo,\n        packageManager: config.packageManager,\n        framework: config.framework,\n        current: currentTree,\n        trees: treesOut,\n      });\n      return;\n    }\n\n    if (out.quiet) {\n      console.log(trees.map(([name]) => name).join('\\n'));\n      return;\n    }\n\n    console.log(chalk.bold('\\nGrove Trees:\\n'));\n\n    const maxNameLen = Math.max(...trees.map(([name]) => name.length));\n    const maxBranchLen = Math.max(...trees.map(([, info]) => info.branch.length));\n\n    for (const [name, info] of trees) {\n      const isCurrent = name === currentTree;\n      const preview = previews[name];\n      const isRunning = preview ? await isPreviewRunning(name, cwd) : false;\n\n      const marker = isCurrent ? chalk.green('â–¸ ') : '  ';\n      const nameStr = isCurrent\n        ? chalk.green(name.padEnd(maxNameLen))\n        : chalk.white(name.padEnd(maxNameLen));\n      const branchStr = chalk.gray(info.branch.padEnd(maxBranchLen));\n\n      let statusStr = '';\n      if (isRunning && preview) {\n        statusStr = chalk.cyan(` [preview :${preview.port}]`);\n      }\n\n      console.log(`${marker}${nameStr}  ${branchStr}${statusStr}`);\n    }\n\n    console.log('');\n    console.log(chalk.gray(`Package manager: ${config.packageManager}`));\n    console.log(chalk.gray(`Framework: ${config.framework}`));\n    console.log('');\n  } catch (error) {\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    process.exit(1);\n  }\n}\n","import { execa, execaCommand, type ExecaChildProcess } from 'execa';\nimport detectPort from 'detect-port';\nimport treeKill from 'tree-kill';\nimport { PreviewInfo, Framework } from '../types.js';\nimport { readConfig, updateConfig } from './config.js';\nimport { getDevCommand, getBuildCommand, getServeCommand, FRAMEWORK_CONFIGS } from './framework.js';\n\nconst runningProcesses: Map<string, ExecaChildProcess> = new Map();\n\nexport async function findAvailablePort(startPort: number = 3000): Promise<number> {\n  return detectPort(startPort);\n}\n\nfunction injectPortIntoCommand(\n  baseCmd: string,\n  framework: Framework,\n  port: number\n): { cmd: string; env: Record<string, string> } {\n  const env: Record<string, string> = {};\n  const trimmed = baseCmd.trim();\n\n  // If user already specified a port/listen flag, don't override (except CRA env below).\n  const alreadyHasPort =\n    /\\b--port\\b/.test(trimmed) ||\n    /\\s-p\\s/.test(trimmed) ||\n    /\\s-l\\s/.test(trimmed) ||\n    /\\b--listen\\b/.test(trimmed);\n\n  // serve CLI uses -l/--listen\n  if (!alreadyHasPort && (trimmed === 'serve' || trimmed.startsWith('serve '))) {\n    return { cmd: `${baseCmd} -l ${port}`, env };\n  }\n\n  // CRA dev server reads PORT env\n  if (framework === 'cra') {\n    env.PORT = String(port);\n    return { cmd: baseCmd, env };\n  }\n\n  if (alreadyHasPort) {\n    return { cmd: baseCmd, env };\n  }\n\n  const portArg = `--port ${port}`;\n  const isScript =\n    /^(npm\\s+run\\b|pnpm\\b|yarn\\b)/.test(trimmed);\n\n  if (isScript) {\n    // Forward args through package manager\n    if (trimmed.includes(' -- ')) {\n      return { cmd: `${baseCmd} ${portArg}`, env };\n    }\n    return { cmd: `${baseCmd} -- ${portArg}`, env };\n  }\n\n  return { cmd: `${baseCmd} ${portArg}`, env };\n}\n\nexport async function startPreview(\n  treeName: string,\n  mode: 'dev' | 'build',\n  cwd: string = process.cwd(),\n  options: { port?: number; portHint?: number } = {}\n): Promise<PreviewInfo> {\n  const config = await readConfig(cwd);\n  const tree = config.trees[treeName];\n\n  if (!tree) {\n    throw new Error(`Tree '${treeName}' not found`);\n  }\n\n  // Check if already running\n  if (config.previews[treeName]) {\n    throw new Error(\n      `Preview for '${treeName}' is already running on port ${config.previews[treeName].port}`\n    );\n  }\n\n  const treePath = tree.path;\n  const defaultPort = FRAMEWORK_CONFIGS[config.framework].defaultPort;\n  // Use portHint if provided (for batch operations), otherwise use default port\n  const desiredPort = options.port ?? options.portHint ?? defaultPort;\n  const port = await findAvailablePort(desiredPort);\n  if (options.port && port !== desiredPort) {\n    throw new Error(`Port ${desiredPort} is not available`);\n  }\n\n  let cmdString: string;\n  let extraEnv: Record<string, string> = {};\n\n  if (mode === 'dev') {\n    const devCmd = await getDevCommand(treePath, config.packageManager);\n    const injected = injectPortIntoCommand(devCmd, config.framework, port);\n    cmdString = injected.cmd;\n    extraEnv = injected.env;\n  } else {\n    // Build first, then serve\n    const buildCmd = await getBuildCommand(treePath, config.packageManager);\n    await execaCommand(buildCmd, {\n      cwd: treePath,\n      stdio: 'inherit',\n    });\n\n    const serveCmd = await getServeCommand(treePath, config.packageManager);\n    const injected = injectPortIntoCommand(serveCmd, config.framework, port);\n    cmdString = injected.cmd;\n    extraEnv = injected.env;\n  }\n\n  // Start the process\n  const child = execaCommand(cmdString, {\n    cwd: treePath,\n    stdio: 'inherit',\n    detached: true,\n    env: {\n      ...process.env,\n      ...extraEnv,\n    },\n  });\n\n  // Don't await - let it run in background\n  child.catch(() => {\n    // Process ended - clean up config\n    cleanupPreview(treeName, cwd).catch(() => {});\n  });\n\n  const pid = child.pid!;\n  runningProcesses.set(treeName, child);\n\n  const previewInfo: PreviewInfo = {\n    pid,\n    port,\n    mode,\n    startedAt: new Date().toISOString(),\n  };\n\n  // Save to config\n  await updateConfig((c) => ({\n    ...c,\n    previews: {\n      ...c.previews,\n      [treeName]: previewInfo,\n    },\n  }), cwd);\n\n  return previewInfo;\n}\n\nexport async function stopPreview(\n  treeName: string,\n  cwd: string = process.cwd()\n): Promise<void> {\n  const config = await readConfig(cwd);\n  const preview = config.previews[treeName];\n\n  if (!preview) {\n    throw new Error(`No preview running for '${treeName}'`);\n  }\n\n  // Kill the process tree\n  await new Promise<void>((resolve, reject) => {\n    treeKill(preview.pid, 'SIGTERM', (err) => {\n      if (err) {\n        // Process might already be dead\n        resolve();\n      } else {\n        resolve();\n      }\n    });\n  });\n\n  await cleanupPreview(treeName, cwd);\n}\n\nexport async function stopAllPreviews(cwd: string = process.cwd()): Promise<void> {\n  const config = await readConfig(cwd);\n\n  for (const treeName of Object.keys(config.previews)) {\n    try {\n      await stopPreview(treeName, cwd);\n    } catch {\n      // Continue stopping others\n    }\n  }\n}\n\nasync function cleanupPreview(\n  treeName: string,\n  cwd: string = process.cwd()\n): Promise<void> {\n  runningProcesses.delete(treeName);\n\n  await updateConfig((c) => {\n    const { [treeName]: _, ...remainingPreviews } = c.previews;\n    return {\n      ...c,\n      previews: remainingPreviews,\n    };\n  }, cwd);\n}\n\nexport async function getRunningPreviews(\n  cwd: string = process.cwd()\n): Promise<Record<string, PreviewInfo>> {\n  const config = await readConfig(cwd);\n  return config.previews;\n}\n\nexport async function isPreviewRunning(\n  treeName: string,\n  cwd: string = process.cwd()\n): Promise<boolean> {\n  const config = await readConfig(cwd);\n  const preview = config.previews[treeName];\n\n  if (!preview) {\n    return false;\n  }\n\n  // Check if process is actually running\n  try {\n    process.kill(preview.pid, 0);\n    return true;\n  } catch {\n    // Process not running - clean up stale entry\n    await cleanupPreview(treeName, cwd);\n    return false;\n  }\n}\n","import chalk from 'chalk';\nimport ora from 'ora';\nimport { readConfig, updateConfig, assertValidTreeName } from '../lib/config.js';\nimport { createCurrentLink, getCurrentTreeName } from '../lib/symlink.js';\nimport { getOutputOptions, shouldUseSpinner, printJson } from '../lib/output.js';\n\nexport async function tend(name: string): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n  const spinner = shouldUseSpinner(out) ? ora(`Switching to '${name}'...`).start() : null;\n\n  try {\n    assertValidTreeName(name);\n    const config = await readConfig(cwd);\n\n    // Check if tree exists\n    if (!config.trees[name]) {\n      if (spinner) spinner.fail(`Tree '${name}' not found`);\n      if (out.json) {\n        printJson({ ok: false, error: `Tree '${name}' not found` });\n      } else if (!out.quiet) {\n        console.log('');\n        console.log(chalk.gray('Available trees:'));\n        for (const treeName of Object.keys(config.trees)) {\n          console.log(chalk.gray(`  - ${treeName}`));\n        }\n      }\n      process.exit(1);\n    }\n\n    const currentTree = await getCurrentTreeName(cwd);\n    if (currentTree === name) {\n      if (spinner) spinner.info(`Already on '${name}'`);\n      if (out.json) {\n        printJson({ ok: true, alreadyCurrent: true, current: name });\n      }\n      return;\n    }\n\n    // Update symlink\n    await createCurrentLink(name, cwd);\n\n    // Update config\n    await updateConfig((c) => ({\n      ...c,\n      current: name,\n    }), cwd);\n\n    const tree = config.trees[name];\n    if (spinner) spinner.succeed(`Now tending '${name}'`);\n\n    if (out.json) {\n      printJson({ ok: true, current: name, tree });\n      return;\n    }\n\n    if (out.quiet) {\n      return;\n    }\n\n    console.log('');\n    console.log(chalk.gray(`  Branch: ${tree.branch}`));\n    console.log(chalk.gray(`  Path:   ${tree.path}`));\n    console.log('');\n    console.log(chalk.cyan('The `current` symlink now points to this tree.'));\n  } catch (error) {\n    if (spinner) spinner.fail('Failed to switch tree');\n    const message = error instanceof Error ? error.message : String(error);\n    if (out.json) {\n      printJson({ ok: false, error: message });\n    } else {\n      console.error(chalk.red(message));\n    }\n    process.exit(1);\n  }\n}\n","import chalk from 'chalk';\nimport ora from 'ora';\nimport path from 'path';\nimport fs from 'fs-extra';\nimport { readConfig, updateConfig, getTreesDir, resolveGroveRoot, assertValidTreeName } from '../lib/config.js';\nimport { removeWorktree } from '../lib/git.js';\nimport { getCurrentTreeName, removeCurrentLink } from '../lib/symlink.js';\nimport { isPreviewRunning, stopPreview } from '../lib/preview.js';\nimport { getOutputOptions, shouldUseSpinner, printJson } from '../lib/output.js';\n\ninterface UprootOptions {\n  force?: boolean;\n}\n\nexport async function uproot(name: string, options: UprootOptions): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n  const spinner = shouldUseSpinner(out) ? ora(`Uprooting '${name}'...`).start() : null;\n\n  try {\n    assertValidTreeName(name);\n    const groveRoot = await resolveGroveRoot(cwd);\n    const config = await readConfig(groveRoot);\n    let switchedTo: string | null = null;\n\n    // Check if tree exists\n    if (!config.trees[name]) {\n      if (spinner) spinner.fail(`Tree '${name}' not found`);\n      if (out.json) {\n        printJson({ ok: false, error: `Tree '${name}' not found` });\n      }\n      process.exit(1);\n    }\n\n    const tree = config.trees[name];\n\n    // Check if this is the main repo (not a real worktree)\n    // The main tree points to the repo root, not .grove/trees/*\n    const treesDir = getTreesDir(groveRoot);\n    const rel = path.relative(treesDir, tree.path);\n    const isRealWorktree = !!rel && !rel.startsWith('..') && !path.isAbsolute(rel);\n\n    if (!isRealWorktree) {\n      if (spinner) spinner.fail(`Cannot uproot '${name}' - it's the main repository`);\n      if (out.json) {\n        printJson({ ok: false, error: `Cannot uproot '${name}' - it's the main repository` });\n      } else if (!out.quiet) {\n        console.log(chalk.gray('The main tree represents your original repository.'));\n        console.log(chalk.gray('You can only uproot worktrees created with `grove plant`.'));\n      }\n      process.exit(1);\n    }\n\n    // Check if it's the current tree\n    const currentTree = await getCurrentTreeName(groveRoot);\n    const isCurrent = currentTree === name;\n\n    if (isCurrent && Object.keys(config.trees).length === 1) {\n      if (spinner) spinner.fail('Cannot uproot the last tree in the grove');\n      if (out.json) {\n        printJson({ ok: false, error: 'Cannot uproot the last tree in the grove' });\n      } else if (!out.quiet) {\n        console.log(chalk.gray('At least one tree must remain.'));\n      }\n      process.exit(1);\n    }\n\n    // Stop preview if running\n    if (await isPreviewRunning(name, groveRoot)) {\n      if (spinner) spinner.text = 'Stopping preview server...';\n      await stopPreview(name, groveRoot);\n    }\n\n    // Remove git worktree\n    if (spinner) spinner.text = 'Removing worktree...';\n    await removeWorktree(tree.path, { force: options.force }, config.repo);\n\n    // Update config\n    await updateConfig((c) => {\n      const { [name]: _, ...remainingTrees } = c.trees;\n      return {\n        ...c,\n        trees: remainingTrees,\n        current: c.current === name ? null : c.current,\n      };\n    }, groveRoot);\n\n    // If this was the current tree, update symlink to another tree\n    if (isCurrent) {\n      const remainingTrees = Object.keys(config.trees).filter((t) => t !== name);\n      if (remainingTrees.length > 0) {\n        const newCurrent = remainingTrees[0];\n        const newTreePath = config.trees[newCurrent].path;\n        switchedTo = newCurrent;\n\n        // Update the symlink to point to the new tree's actual path\n        const currentLinkPath = path.join(groveRoot, 'current');\n        // Use lstat to check for symlink (pathExists follows symlinks)\n        try {\n          await fs.lstat(currentLinkPath);\n          await fs.unlink(currentLinkPath);\n        } catch {\n          // Symlink doesn't exist, that's fine\n        }\n        // If the new tree is the main repo (same as cwd), use '.' as the symlink target\n        const relativePath = path.relative(groveRoot, newTreePath) || '.';\n        await fs.symlink(relativePath, currentLinkPath);\n\n        await updateConfig((c) => ({\n          ...c,\n          current: newCurrent,\n        }), groveRoot);\n        if (spinner) spinner.succeed(`Uprooted '${name}', switched to '${newCurrent}'`);\n      } else {\n        switchedTo = null;\n        await removeCurrentLink(groveRoot);\n        if (spinner) spinner.succeed(`Uprooted '${name}'`);\n      }\n    } else {\n      if (spinner) spinner.succeed(`Uprooted '${name}'`);\n    }\n\n    if (out.json) {\n      printJson({\n        ok: true,\n        removed: { name, ...tree },\n        switchedTo,\n      });\n      return;\n    }\n\n    if (out.quiet) {\n      return;\n    }\n\n    console.log('');\n    console.log(chalk.gray(`  Branch: ${tree.branch}`));\n    console.log(chalk.gray(`  Path:   ${tree.path} (removed)`));\n  } catch (error) {\n    if (spinner) spinner.fail('Failed to uproot tree');\n    const message = error instanceof Error ? error.message : String(error);\n    if (out.json) {\n      printJson({ ok: false, error: message });\n    } else {\n      console.error(chalk.red(message));\n      if (!options.force && !out.quiet) {\n        console.log('');\n        console.log(chalk.yellow('Tip: Use --force to force removal'));\n      }\n    }\n    process.exit(1);\n  }\n}\n","import chalk from 'chalk';\nimport ora from 'ora';\nimport { readConfig, assertValidTreeName } from '../lib/config.js';\nimport {\n  startPreview as startPreviewServer,\n  stopPreview as stopPreviewServer,\n  stopAllPreviews,\n  isPreviewRunning,\n} from '../lib/preview.js';\nimport { getOutputOptions, shouldUseSpinner, printJson } from '../lib/output.js';\n\ninterface PreviewOptions {\n  dev?: boolean;\n  build?: boolean;\n  port?: number;\n  all?: boolean;\n}\n\nexport async function preview(\n  action: string,\n  names: string[] | undefined,\n  options: PreviewOptions\n): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n\n  let config: Awaited<ReturnType<typeof readConfig>>;\n  try {\n    config = await readConfig(cwd);\n  } catch (e) {\n    const message = e instanceof Error ? e.message : String(e);\n    if (out.json) {\n      printJson({ ok: false, error: message });\n    } else if (!out.quiet) {\n      console.error(chalk.red(message));\n    }\n    process.exit(1);\n  }\n\n  // Handle 'stop' action\n  if (action === 'stop') {\n    const targets = names ?? [];\n    if (targets.length === 0) {\n      await stopAll(cwd, out, config);\n      return;\n    }\n    for (const t of targets) {\n      assertValidTreeName(t);\n    }\n    await stopMany(targets, cwd, out);\n    return;\n  }\n\n  // Determine targets for start\n  const isAll = options.all || action === 'all';\n  const targets = isAll ? Object.keys(config.trees) : [action, ...(names ?? [])];\n  for (const t of targets) {\n    assertValidTreeName(t);\n  }\n\n  if (targets.length > 1 && options.port) {\n    if (!out.quiet) {\n      console.log(chalk.yellow('Note: --port is only supported for a single tree; ignoring it.'));\n    }\n    options = { ...options, port: undefined };\n  }\n\n  await startMany(targets, options, cwd, out, config);\n}\n\nasync function startMany(\n  targets: string[],\n  options: PreviewOptions,\n  cwd: string,\n  out: ReturnType<typeof getOutputOptions>,\n  config: Awaited<ReturnType<typeof readConfig>>\n): Promise<void> {\n  const mode = options.build ? 'build' : 'dev';\n\n  const results: Array<{ name: string; url?: string; error?: string; alreadyRunning?: boolean }> = [];\n\n  // Track allocated ports to avoid conflicts when starting multiple previews\n  let nextPortHint = 3000;\n\n  for (const name of targets) {\n    if (!config.trees[name]) {\n      results.push({ name, error: `Tree '${name}' not found` });\n      continue;\n    }\n\n    try {\n      if (await isPreviewRunning(name, cwd)) {\n        const preview = config.previews[name];\n        results.push({\n          name,\n          alreadyRunning: true,\n          url: `http://localhost:${preview.port}`,\n        });\n        continue;\n      }\n\n      const spinner = shouldUseSpinner(out)\n        ? ora(`Starting preview for '${name}'...`).start()\n        : null;\n      if (spinner) spinner.text = mode === 'build'\n        ? 'Building and starting server...'\n        : 'Starting dev server...';\n\n      const previewInfo = await startPreviewServer(name, mode, cwd, {\n        port: options.port,\n        portHint: nextPortHint\n      });\n      const url = `http://localhost:${previewInfo.port}`;\n      results.push({ name, url });\n\n      // Update port hint for next preview to avoid conflicts\n      nextPortHint = previewInfo.port + 1;\n\n      if (spinner) spinner.succeed(`Preview started for '${name}'`);\n    } catch (err) {\n      results.push({\n        name,\n        error: err instanceof Error ? err.message : String(err),\n      });\n      if (!out.quiet && !out.json) {\n        console.error(chalk.red(`Failed to start preview for '${name}': ${results[results.length - 1].error}`));\n      }\n    }\n  }\n\n  if (out.json) {\n    printJson({ ok: results.every((r) => !r.error), mode, results });\n    if (results.some((r) => r.error)) process.exit(1);\n    return;\n  }\n\n  if (out.quiet) {\n    for (const r of results) {\n      if (r.url) console.log(r.url);\n    }\n    if (results.some((r) => r.error)) process.exit(1);\n    return;\n  }\n\n  if (results.length > 1) {\n    console.log('');\n    console.log(chalk.green('Previews:'));\n    for (const r of results) {\n      if (r.error) {\n        console.log(chalk.red(`  ${r.name}: ${r.error}`));\n      } else if (r.url) {\n        const label = r.alreadyRunning ? 'running' : 'started';\n        console.log(chalk.cyan(`  ${r.name} (${label}) â†’ ${r.url}`));\n      }\n    }\n  }\n\n  if (results.some((r) => r.error)) {\n    process.exit(1);\n  }\n}\n\nasync function stopTree(\n  name: string,\n  cwd: string,\n  out: ReturnType<typeof getOutputOptions>\n): Promise<void> {\n  const spinner = shouldUseSpinner(out) ? ora(`Stopping preview for '${name}'...`).start() : null;\n\n  try {\n    if (!(await isPreviewRunning(name, cwd))) {\n      if (spinner) spinner.info(`No preview running for '${name}'`);\n      if (out.json) {\n        printJson({ ok: true, running: false });\n      }\n      return;\n    }\n\n    await stopPreviewServer(name, cwd);\n    if (spinner) spinner.succeed(`Stopped preview for '${name}'`);\n    if (out.json) {\n      printJson({ ok: true, stopped: true, name });\n      return;\n    }\n  } catch (error) {\n    if (spinner) spinner.fail('Failed to stop preview');\n    const message = error instanceof Error ? error.message : String(error);\n    if (out.json) {\n      printJson({ ok: false, error: message });\n    } else {\n      console.error(chalk.red(message));\n    }\n    process.exit(1);\n  }\n}\n\nasync function stopMany(\n  targets: string[],\n  cwd: string,\n  out: ReturnType<typeof getOutputOptions>\n): Promise<void> {\n  const results: Array<{ name: string; stopped?: boolean; error?: string }> = [];\n  for (const name of targets) {\n    try {\n      if (!(await isPreviewRunning(name, cwd))) {\n        results.push({ name, stopped: false });\n        continue;\n      }\n      await stopPreviewServer(name, cwd);\n      results.push({ name, stopped: true });\n    } catch (err) {\n      results.push({ name, error: err instanceof Error ? err.message : String(err) });\n    }\n  }\n\n  if (out.json) {\n    printJson({ ok: results.every((r) => !r.error), results });\n    if (results.some((r) => r.error)) process.exit(1);\n    return;\n  }\n\n  if (out.quiet) {\n    if (results.some((r) => r.error)) process.exit(1);\n    return;\n  }\n\n  console.log('');\n  console.log(chalk.green('Stopped previews:'));\n  for (const r of results) {\n    if (r.error) {\n      console.log(chalk.red(`  ${r.name}: ${r.error}`));\n    } else {\n      const label = r.stopped ? 'stopped' : 'not running';\n      console.log(chalk.gray(`  ${r.name}: ${label}`));\n    }\n  }\n\n  if (results.some((r) => r.error)) {\n    process.exit(1);\n  }\n}\n\nasync function stopAll(\n  cwd: string,\n  out: ReturnType<typeof getOutputOptions>,\n  config?: Awaited<ReturnType<typeof readConfig>>\n): Promise<void> {\n  const spinner = shouldUseSpinner(out) ? ora('Stopping all previews...').start() : null;\n\n  try {\n    const cfg = config ?? await readConfig(cwd);\n    const runningCount = Object.keys(cfg.previews).length;\n\n    if (runningCount === 0) {\n      if (spinner) spinner.info('No previews running');\n      if (out.json) {\n        printJson({ ok: true, stopped: 0 });\n      }\n      return;\n    }\n\n    await stopAllPreviews(cwd);\n    if (spinner) spinner.succeed(`Stopped ${runningCount} preview(s)`);\n    if (out.json) {\n      printJson({ ok: true, stopped: runningCount });\n    }\n  } catch (error) {\n    if (spinner) spinner.fail('Failed to stop previews');\n    const message = error instanceof Error ? error.message : String(error);\n    if (out.json) {\n      printJson({ ok: false, error: message });\n    } else {\n      console.error(chalk.red(message));\n    }\n    process.exit(1);\n  }\n}\n","import chalk from 'chalk';\nimport { readConfig } from '../lib/config.js';\nimport { getCurrentTreeName } from '../lib/symlink.js';\nimport { getRunningPreviews, isPreviewRunning } from '../lib/preview.js';\nimport { getOutputOptions, printJson } from '../lib/output.js';\nimport type { PreviewInfo } from '../types.js';\n\nexport async function status(): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n\n  try {\n    const config = await readConfig(cwd);\n    const currentTree = await getCurrentTreeName(cwd);\n    const previews = await getRunningPreviews(cwd);\n\n    const previewEntries = Object.entries(previews);\n    const runningFlags = await Promise.all(\n      previewEntries.map(([name]) => isPreviewRunning(name, cwd))\n    );\n    const runningPreviews = previewEntries\n      .filter((_, i) => runningFlags[i])\n      .reduce<Record<string, PreviewInfo>>((acc, [name, preview]) => {\n        acc[name] = preview;\n        return acc;\n      }, {});\n\n    const treeCount = Object.keys(config.trees).length;\n    const runningCount = runningFlags.filter(Boolean).length;\n\n    if (out.json) {\n      const current = currentTree && config.trees[currentTree]\n        ? { name: currentTree, ...config.trees[currentTree] }\n        : null;\n\n      printJson({\n        current,\n        previews: runningPreviews,\n        summary: {\n          trees: treeCount,\n          previewsRunning: runningCount,\n          packageManager: config.packageManager,\n          framework: config.framework,\n        },\n      });\n      return;\n    }\n\n    if (out.quiet) {\n      if (currentTree) {\n        console.log(currentTree);\n      }\n      return;\n    }\n\n    console.log(chalk.bold('\\nGrove Status\\n'));\n\n    // Current tree\n    console.log(chalk.white('Current Tree:'));\n    if (currentTree && config.trees[currentTree]) {\n      const tree = config.trees[currentTree];\n      console.log(chalk.green(`  ${currentTree}`));\n      console.log(chalk.gray(`  Branch: ${tree.branch}`));\n      console.log(chalk.gray(`  Path: ./current`));\n    } else {\n      console.log(chalk.yellow('  None selected'));\n    }\n    console.log('');\n\n    // Running previews\n    console.log(chalk.white('Running Previews:'));\n    if (previewEntries.length === 0) {\n      console.log(chalk.gray('  No previews running'));\n    } else {\n      for (const [name, preview] of Object.entries(runningPreviews)) {\n        console.log(\n          chalk.cyan(`  ${name}`) +\n          chalk.gray(` â†’ http://localhost:${preview.port}`) +\n          chalk.gray(` (${preview.mode})`)\n        );\n      }\n    }\n    console.log('');\n\n    // Summary\n    console.log(chalk.white('Summary:'));\n    console.log(chalk.gray(`  Trees: ${treeCount}`));\n    console.log(chalk.gray(`  Previews running: ${runningCount}`));\n    console.log(chalk.gray(`  Package manager: ${config.packageManager}`));\n    console.log(chalk.gray(`  Framework: ${config.framework}`));\n    console.log('');\n  } catch (error) {\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    process.exit(1);\n  }\n}\n","import chalk from 'chalk';\nimport ora from 'ora';\nimport { readConfig, assertValidTreeName } from '../lib/config.js';\nimport { getOutputOptions, shouldUseSpinner, printJson } from '../lib/output.js';\nimport {\n  Editor,\n  openInEditor,\n  detectAvailableEditors,\n  getEditorName,\n  getSupportedEditors,\n} from '../lib/editor.js';\n\ninterface OpenOptions {\n  editor?: string;\n}\n\nexport async function open(name: string, options: OpenOptions): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n\n  try {\n    assertValidTreeName(name);\n    const config = await readConfig(cwd);\n\n    // Validate tree exists\n    if (!config.trees[name]) {\n      if (out.json) {\n        printJson({ ok: false, error: `Tree '${name}' not found` });\n      } else if (!out.quiet) {\n        console.log(chalk.red(`Tree '${name}' not found`));\n        console.log('');\n        console.log(chalk.gray('Available trees:'));\n        for (const treeName of Object.keys(config.trees)) {\n          console.log(chalk.gray(`  - ${treeName}`));\n        }\n      }\n      process.exit(1);\n    }\n\n    // Determine which editor to use\n    let editor: Editor;\n\n    if (options.editor) {\n      const supported = getSupportedEditors();\n      if (!supported.includes(options.editor as Editor)) {\n        if (out.json) {\n          printJson({ ok: false, error: `Unknown editor: ${options.editor}` });\n        } else if (!out.quiet) {\n          console.log(chalk.red(`Unknown editor: ${options.editor}`));\n          console.log(chalk.gray(`Supported: ${supported.join(', ')}`));\n        }\n        process.exit(1);\n      }\n      editor = options.editor as Editor;\n    } else {\n      // Auto-detect available editor (prefer cursor for AI workflows)\n      const available = await detectAvailableEditors();\n\n      if (available.length === 0) {\n        if (out.json) {\n          printJson({ ok: false, error: 'No supported editors found' });\n        } else if (!out.quiet) {\n          console.log(chalk.red('No supported editors found'));\n          console.log(chalk.gray('Install one of: cursor, code (VS Code), claude, zed'));\n        }\n        process.exit(1);\n      }\n\n      // Preference order for AI coding\n      const preferenceOrder: Editor[] = ['cursor', 'claude', 'code', 'zed'];\n      editor = preferenceOrder.find((e) => available.includes(e)) || available[0];\n    }\n\n    const spinner = shouldUseSpinner(out)\n      ? ora(`Opening '${name}' in ${getEditorName(editor)}...`).start()\n      : null;\n\n    await openInEditor(name, editor, cwd);\n\n    const treePath = config.trees[name].path;\n    if (spinner) spinner.succeed(`Opened '${name}' in ${getEditorName(editor)}`);\n\n    if (out.json) {\n      printJson({\n        ok: true,\n        opened: { name, path: treePath, branch: config.trees[name].branch },\n        editor,\n      });\n      return;\n    }\n\n    if (out.quiet) {\n      return;\n    }\n\n    console.log('');\n    console.log(chalk.gray(`  Path: ${treePath}`));\n    console.log(chalk.gray(`  Branch: ${config.trees[name].branch}`));\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    if (out.json) {\n      printJson({ ok: false, error: message });\n    } else {\n      console.error(chalk.red(message));\n    }\n    process.exit(1);\n  }\n}\n","import chalk from 'chalk';\nimport { readConfig, assertValidTreeName } from '../lib/config.js';\nimport { spawnClaudeCode } from '../lib/editor.js';\nimport { getOutputOptions, printJson } from '../lib/output.js';\n\nexport async function spawn(name: string): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n\n  try {\n    assertValidTreeName(name);\n    const config = await readConfig(cwd);\n\n    // Validate tree exists\n    if (!config.trees[name]) {\n      if (out.json) {\n        printJson({ ok: false, error: `Tree '${name}' not found` });\n      } else if (!out.quiet) {\n        console.log(chalk.red(`Tree '${name}' not found`));\n        console.log('');\n        console.log(chalk.gray('Available trees:'));\n        for (const treeName of Object.keys(config.trees)) {\n          console.log(chalk.gray(`  - ${treeName}`));\n        }\n      }\n      process.exit(1);\n    }\n\n    const tree = config.trees[name];\n    const treePath = tree.path;\n\n    if (out.json) {\n      printJson({ ok: false, error: '--json is not supported for interactive spawn sessions' });\n      process.exit(1);\n    }\n\n    if (!out.quiet) {\n      console.log(chalk.cyan(`Spawning Claude Code in '${name}'...`));\n      console.log(chalk.gray(`  Path: ${treePath}`));\n      console.log(chalk.gray(`  Branch: ${tree.branch}`));\n      console.log('');\n    }\n\n    // This will block until Claude Code exits\n    await spawnClaudeCode(name, cwd);\n\n    if (!out.quiet) {\n      console.log('');\n      console.log(chalk.gray('Claude Code session ended.'));\n    }\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    if (out.json) {\n      printJson({ ok: false, error: message });\n    } else {\n      console.error(chalk.red(message));\n    }\n    process.exit(1);\n  }\n}\n","import { readConfig, assertValidTreeName } from '../lib/config.js';\nimport { getOutputOptions, printJson } from '../lib/output.js';\n\nexport async function getPath(name: string): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n\n  try {\n    assertValidTreeName(name);\n    const config = await readConfig(cwd);\n\n    // Validate tree exists\n    if (!config.trees[name]) {\n      console.error(`Tree '${name}' not found`);\n      process.exit(1);\n    }\n\n    const tree = config.trees[name];\n    const treePath = tree.path;\n\n    if (out.json) {\n      printJson({ name, path: treePath, branch: tree.branch });\n      return;\n    }\n\n    // Output just the path - useful for shell integration\n    // e.g., cd $(grove path feature-x)\n    console.log(treePath);\n  } catch (error) {\n    console.error(error instanceof Error ? error.message : String(error));\n    process.exit(1);\n  }\n}\n","import chalk from 'chalk';\nimport { execa } from 'execa';\nimport { assertValidTreeName, readConfig, resolveGroveRoot } from '../lib/config.js';\nimport { getOutputOptions, printJson } from '../lib/output.js';\n\nconst SUPPORTED_TOOLS = ['claude', 'codex', 'run'] as const;\ntype SupportedTool = (typeof SUPPORTED_TOOLS)[number];\n\nfunction isSupportedTool(tool: string): tool is SupportedTool {\n  return (SUPPORTED_TOOLS as readonly string[]).includes(tool);\n}\n\nexport async function ai(\n  tool: string,\n  name: string,\n  args: string[] = []\n): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n\n  if (out.json) {\n    printJson({ ok: false, error: '--json is not supported for interactive AI sessions' });\n    process.exit(1);\n  }\n\n  try {\n    assertValidTreeName(name);\n\n    if (!isSupportedTool(tool)) {\n      if (!out.quiet) {\n        console.error(chalk.red(`Unknown AI tool: ${tool}`));\n        console.error(chalk.gray(`Supported: ${SUPPORTED_TOOLS.join(', ')}`));\n      }\n      process.exit(1);\n    }\n\n    const groveRoot = await resolveGroveRoot(cwd);\n    const config = await readConfig(groveRoot);\n\n    if (!config.trees[name]) {\n      if (!out.quiet) {\n        console.error(chalk.red(`Tree '${name}' not found`));\n      }\n      process.exit(1);\n    }\n\n    const tree = config.trees[name];\n    const treePath = tree.path;\n\n    let command: string;\n    let commandArgs: string[];\n\n    if (tool === 'run') {\n      if (args.length === 0) {\n        if (!out.quiet) {\n          console.error(chalk.red('No command provided for `grove ai run`'));\n          console.error(chalk.gray('Usage: grove ai run <name> -- <command> [args...]'));\n        }\n        process.exit(1);\n      }\n      command = args[0];\n      commandArgs = args.slice(1);\n    } else {\n      command = tool;\n      commandArgs = args;\n    }\n\n    if (!out.quiet) {\n      const label = tool === 'run' ? command : tool;\n      console.log(chalk.cyan(`Starting ${label} in '${name}'...`));\n      console.log(chalk.gray(`  Path: ${treePath}`));\n      console.log(chalk.gray(`  Branch: ${tree.branch}`));\n      console.log('');\n    }\n\n    const env = {\n      ...process.env,\n      GROVE_TREE: name,\n      GROVE_TREE_PATH: treePath,\n      GROVE_BRANCH: tree.branch,\n      GROVE_ROOT: groveRoot,\n      GROVE_REPO: config.repo,\n    };\n\n    await execa(command, commandArgs, {\n      cwd: treePath,\n      stdio: 'inherit',\n      env,\n    });\n  } catch (error) {\n    if (!out.quiet) {\n      console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    }\n    process.exit(1);\n  }\n}\n\n","import chalk from 'chalk';\nimport ora from 'ora';\nimport path from 'path';\nimport { readConfig, updateConfig, resolveGroveRoot, assertValidTreeName } from '../lib/config.js';\nimport { listWorktrees } from '../lib/git.js';\nimport { createCurrentLink } from '../lib/symlink.js';\nimport { getOutputOptions, shouldUseSpinner, printJson } from '../lib/output.js';\n\ninterface AdoptOptions {\n  switch?: boolean;\n}\n\nexport async function adopt(\n  worktreePath: string,\n  name: string | undefined,\n  options: AdoptOptions\n): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n  const spinner = shouldUseSpinner(out) ? ora(`Adopting worktree...`).start() : null;\n\n  try {\n    const groveRoot = await resolveGroveRoot(cwd);\n    const config = await readConfig(groveRoot);\n\n    const targetAbs = path.resolve(cwd, worktreePath);\n    const worktrees = await listWorktrees(config.repo);\n    const match = worktrees.find((wt) => path.resolve(wt.path) === targetAbs);\n\n    if (!match) {\n      if (spinner) spinner.fail('Worktree not found');\n      if (out.json) {\n        printJson({ ok: false, error: `No git worktree found at ${targetAbs}` });\n      } else if (!out.quiet) {\n        console.error(chalk.red(`No git worktree found at ${targetAbs}`));\n      }\n      process.exit(1);\n    }\n\n    const derivedName = match.branch ? match.branch.replace(/\\//g, '-') : undefined;\n    const treeName = name || derivedName;\n\n    if (!treeName) {\n      if (spinner) spinner.fail('Name required');\n      if (out.json) {\n        printJson({ ok: false, error: 'Detached worktree requires an explicit name' });\n      } else if (!out.quiet) {\n        console.error(chalk.red('Detached worktree requires an explicit name.'));\n      }\n      process.exit(1);\n    }\n\n    assertValidTreeName(treeName);\n\n    if (config.trees[treeName]) {\n      if (spinner) spinner.fail(`Tree '${treeName}' already exists`);\n      if (out.json) {\n        printJson({ ok: false, error: `Tree '${treeName}' already exists` });\n      }\n      process.exit(1);\n    }\n\n    const duplicatePath = Object.values(config.trees).some(\n      (t) => path.resolve(t.path) === targetAbs\n    );\n    if (duplicatePath) {\n      if (spinner) spinner.fail('Worktree already adopted');\n      if (out.json) {\n        printJson({ ok: false, error: `Worktree at ${targetAbs} is already adopted` });\n      }\n      process.exit(1);\n    }\n\n    const createdAt = new Date().toISOString();\n    const storedBranch = match.branch ?? match.head;\n\n    await updateConfig((c) => ({\n      ...c,\n      trees: {\n        ...c.trees,\n        [treeName]: {\n          branch: storedBranch,\n          path: targetAbs,\n          created: createdAt,\n        },\n      },\n    }), groveRoot);\n\n    if (options.switch) {\n      await createCurrentLink(treeName, groveRoot);\n      await updateConfig((c) => ({ ...c, current: treeName }), groveRoot);\n    }\n\n    if (spinner) spinner.succeed(`Adopted '${treeName}'`);\n\n    if (out.json) {\n      printJson({\n        ok: true,\n        adopted: { name: treeName, branch: storedBranch, path: targetAbs, created: createdAt },\n        switched: !!options.switch,\n      });\n      return;\n    }\n\n    if (out.quiet) return;\n\n    console.log('');\n    console.log(chalk.green('Adopted tree:'));\n    console.log(chalk.gray(`  Name:   ${treeName}`));\n    console.log(chalk.gray(`  Branch: ${storedBranch}`));\n    console.log(chalk.gray(`  Path:   ${targetAbs}`));\n    if (options.switch) {\n      console.log('');\n      console.log(chalk.cyan(`Switched to '${treeName}'`));\n    }\n  } catch (error) {\n    if (spinner) spinner.fail('Failed to adopt worktree');\n    const message = error instanceof Error ? error.message : String(error);\n    if (out.json) {\n      printJson({ ok: false, error: message });\n    } else if (!out.quiet) {\n      console.error(chalk.red(message));\n    }\n    process.exit(1);\n  }\n}\n\n","import chalk from 'chalk';\nimport ora from 'ora';\nimport path from 'path';\nimport { readConfig, updateConfig, resolveGroveRoot } from '../lib/config.js';\nimport { listWorktrees } from '../lib/git.js';\nimport { getOutputOptions, shouldUseSpinner, printJson } from '../lib/output.js';\n\ninterface PruneOptions {\n  dryRun?: boolean;\n}\n\nexport async function prune(options: PruneOptions): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n  const spinner = shouldUseSpinner(out) ? ora('Pruning stale trees...').start() : null;\n\n  try {\n    const groveRoot = await resolveGroveRoot(cwd);\n    const config = await readConfig(groveRoot);\n\n    const worktrees = await listWorktrees(config.repo);\n    const actualPaths = new Set(worktrees.map((wt) => path.resolve(wt.path)));\n\n    const staleTrees = Object.entries(config.trees)\n      .filter(([name]) => name !== 'main')\n      .filter(([, tree]) => !actualPaths.has(path.resolve(tree.path)))\n      .map(([name]) => name);\n\n    const stalePreviews = Object.keys(config.previews).filter((name) =>\n      staleTrees.includes(name)\n    );\n\n    if (!options.dryRun && (staleTrees.length > 0 || stalePreviews.length > 0)) {\n      await updateConfig((c) => {\n        const remainingTrees = { ...c.trees };\n        for (const name of staleTrees) {\n          delete remainingTrees[name];\n        }\n        const remainingPreviews = { ...c.previews };\n        for (const name of stalePreviews) {\n          delete remainingPreviews[name];\n        }\n\n        const currentIsStale = c.current && staleTrees.includes(c.current);\n        const current = currentIsStale ? (Object.keys(remainingTrees)[0] ?? null) : c.current;\n\n        return {\n          ...c,\n          trees: remainingTrees,\n          previews: remainingPreviews,\n          current,\n        };\n      }, groveRoot);\n    }\n\n    if (spinner) spinner.succeed('Prune complete');\n\n    if (out.json) {\n      printJson({\n        ok: true,\n        dryRun: !!options.dryRun,\n        prunedTrees: staleTrees,\n        prunedPreviews: stalePreviews,\n      });\n      return;\n    }\n\n    if (out.quiet) {\n      if (staleTrees.length > 0) {\n        console.log(staleTrees.join('\\n'));\n      }\n      return;\n    }\n\n    if (staleTrees.length === 0 && stalePreviews.length === 0) {\n      console.log(chalk.gray('No stale trees or previews found.'));\n      return;\n    }\n\n    console.log('');\n    if (staleTrees.length > 0) {\n      console.log(chalk.green(`Pruned trees: ${staleTrees.join(', ')}`));\n    }\n    if (stalePreviews.length > 0) {\n      console.log(chalk.green(`Pruned previews: ${stalePreviews.join(', ')}`));\n    }\n    if (options.dryRun) {\n      console.log(chalk.yellow('(dry run; no changes made)'));\n    }\n  } catch (error) {\n    if (spinner) spinner.fail('Failed to prune trees');\n    const message = error instanceof Error ? error.message : String(error);\n    if (out.json) {\n      printJson({ ok: false, error: message });\n    } else if (!out.quiet) {\n      console.error(chalk.red(message));\n    }\n    process.exit(1);\n  }\n}\n\n","import chalk from 'chalk';\nimport ora from 'ora';\nimport path from 'path';\nimport {\n  readConfig,\n  updateConfig,\n  resolveGroveRoot,\n} from '../lib/config.js';\nimport { listWorktrees } from '../lib/git.js';\nimport {\n  isSymlinkValid,\n  getCurrentTreeName,\n  createCurrentLink,\n  removeCurrentLink,\n} from '../lib/symlink.js';\nimport { getOutputOptions, shouldUseSpinner, printJson } from '../lib/output.js';\n\ninterface DoctorOptions {\n  fix?: boolean;\n}\n\nexport async function doctor(options: DoctorOptions): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n  const spinner = shouldUseSpinner(out) ? ora('Checking grove health...').start() : null;\n\n  try {\n    const groveRoot = await resolveGroveRoot(cwd);\n    const config = await readConfig(groveRoot);\n\n    const worktrees = await listWorktrees(config.repo);\n    const actualPaths = new Set(worktrees.map((wt) => path.resolve(wt.path)));\n\n    const missingTrees = Object.entries(config.trees)\n      .filter(([name]) => name !== 'main')\n      .filter(([, tree]) => !actualPaths.has(path.resolve(tree.path)))\n      .map(([name, tree]) => ({ name, path: tree.path }));\n\n    const previewEntries = Object.entries(config.previews);\n    const stalePreviews = previewEntries.filter(([, preview]) => {\n      try {\n        process.kill(preview.pid, 0);\n        return false;\n      } catch {\n        return true;\n      }\n    }).map(([name, preview]) => ({ name, pid: preview.pid, port: preview.port }));\n\n    const symlinkOk = await isSymlinkValid(groveRoot);\n    const symlinkCurrent = await getCurrentTreeName(groveRoot);\n    const configCurrent = config.current;\n\n    const issues: Array<Record<string, unknown>> = [];\n    if (missingTrees.length > 0) {\n      issues.push({ type: 'missing_trees', trees: missingTrees });\n    }\n    if (stalePreviews.length > 0) {\n      issues.push({ type: 'stale_previews', previews: stalePreviews });\n    }\n    if (!symlinkOk) {\n      issues.push({ type: 'invalid_current_symlink' });\n    }\n    if (configCurrent && symlinkCurrent && configCurrent !== symlinkCurrent) {\n      issues.push({ type: 'current_mismatch', configCurrent, symlinkCurrent });\n    }\n    if (configCurrent && !config.trees[configCurrent]) {\n      issues.push({ type: 'current_missing', current: configCurrent });\n    }\n\n    if (options.fix) {\n      const missingNames = missingTrees.map((t) => t.name);\n      const remainingTrees = { ...config.trees };\n      for (const name of missingNames) {\n        delete remainingTrees[name];\n      }\n\n      const remainingPreviews = { ...config.previews };\n      for (const name of missingNames) {\n        delete remainingPreviews[name];\n      }\n      for (const { name } of stalePreviews) {\n        delete remainingPreviews[name];\n      }\n\n      const candidates = [\n        configCurrent,\n        symlinkCurrent,\n        remainingTrees['main'] ? 'main' : null,\n        Object.keys(remainingTrees)[0] ?? null,\n      ].filter((c): c is string => !!c && !!remainingTrees[c]);\n\n      const newCurrent = candidates[0] ?? null;\n\n      await updateConfig((c) => ({\n        ...c,\n        trees: remainingTrees,\n        previews: remainingPreviews,\n        current: newCurrent,\n      }), groveRoot);\n\n      if (newCurrent) {\n        await createCurrentLink(newCurrent, groveRoot);\n      } else {\n        await removeCurrentLink(groveRoot);\n      }\n\n      if (spinner) spinner.succeed('Grove repaired');\n\n      if (out.json) {\n        printJson({\n          ok: true,\n          fixed: true,\n          prunedTrees: missingNames,\n          prunedPreviews: stalePreviews.map((p) => p.name),\n          current: newCurrent,\n        });\n        return;\n      }\n\n      if (out.quiet) return;\n\n      console.log(chalk.green('Grove repaired.'));\n      if (missingNames.length > 0) {\n        console.log(chalk.gray(`Pruned trees: ${missingNames.join(', ')}`));\n      }\n      if (stalePreviews.length > 0) {\n        console.log(chalk.gray(`Pruned previews: ${stalePreviews.map((p) => p.name).join(', ')}`));\n      }\n      if (newCurrent) {\n        console.log(chalk.gray(`Current tree: ${newCurrent}`));\n      }\n      return;\n    }\n\n    if (spinner) spinner.succeed('Doctor complete');\n\n    if (out.json) {\n      printJson({ ok: issues.length === 0, issues });\n      return;\n    }\n\n    if (out.quiet) {\n      if (issues.length > 0) process.exit(1);\n      return;\n    }\n\n    if (issues.length === 0) {\n      console.log(chalk.green('All good. No issues found.'));\n      return;\n    }\n\n    console.log(chalk.yellow('Issues found:'));\n    for (const issue of issues) {\n      console.log(chalk.gray(`- ${issue.type}`));\n    }\n    console.log('');\n    console.log(chalk.gray('Run `grove doctor --fix` to repair.'));\n    process.exit(1);\n  } catch (error) {\n    if (spinner) spinner.fail('Doctor failed');\n    const message = error instanceof Error ? error.message : String(error);\n    if (out.json) {\n      printJson({ ok: false, error: message });\n    } else if (!out.quiet) {\n      console.error(chalk.red(message));\n    }\n    process.exit(1);\n  }\n}\n\n","import chalk from 'chalk';\nimport ora from 'ora';\nimport path from 'path';\nimport fs from 'fs-extra';\nimport { resolveGroveRoot } from '../lib/config.js';\nimport { getOutputOptions, shouldUseSpinner, printJson } from '../lib/output.js';\n\ninterface ClaudeSetupOptions {\n  dryRun?: boolean;\n  force?: boolean;\n  settings?: boolean;\n}\n\nconst DEFAULT_GROVE_SKILL_MD = `---\nname: grove\ndescription: Use this skill when the user wants to work with git worktrees, manage multiple branches simultaneously, or run parallel AI development environments.\n---\n\n# Grove - Git Worktree Manager\n\nUse this skill when the user wants to work with git worktrees, manage multiple branches simultaneously, or run parallel AI development environments.\n\n## What is Grove?\n\nGrove is a CLI tool that manages git worktrees with smart dependency handling. It's designed for AI-assisted development workflows where you need to:\n\n- Work on multiple branches simultaneously\n- Run preview servers for different branches\n- Avoid reinstalling node_modules for every branch\n- Open different branches in separate editor windows\n\n## Key Commands\n\n- Initialize in a repo: \\`grove init\\`\n- Create a new tree: \\`grove plant <branch> [name]\\`\n- Switch current tree: \\`grove tend <name>\\`\n- List trees: \\`grove list\\`\n- Remove a tree: \\`grove uproot <name> [--force]\\`\n- Adopt existing worktree: \\`grove adopt <path> [name]\\`\n- Health / cleanup: \\`grove doctor [--fix]\\`, \\`grove prune [--dry-run]\\`\n\n## AI Sessions\n\nStart AI tools inside a tree:\n\n- Claude Code: \\`grove ai claude <name>\\`\n- Codex CLI: \\`grove ai codex <name>\\`\n- Any command: \\`grove ai run <name> -- <command> [args...]\\`\n\nAI sessions inherit helpful environment variables like \\`GROVE_TREE\\`, \\`GROVE_TREE_PATH\\`, and \\`GROVE_REPO\\`.\n\n## Preview Servers\n\n- Start a preview: \\`grove preview <name>\\`\n- Start multiple previews: \\`grove preview <name-a> <name-b>\\`\n- Start all previews: \\`grove preview all\\` or \\`grove preview --all\\`\n- Stop previews: \\`grove preview stop [names...]\\`\n- Specific port (single tree): \\`grove preview <name> --port 4000\\`\n\n## Single-Session Multi-Variant Workflow\n\nWhen the user wants two different implementations/designs:\n\n1. Create two worktrees:\n   - \\`grove plant -n <variant-a> -b main --no-install\\`\n   - \\`grove plant -n <variant-b> -b main --no-install\\`\n2. Get their paths:\n   - \\`grove path <variant-a>\\`\n   - \\`grove path <variant-b>\\`\n3. Edit each variant by targeting files under each path separately.\n4. Preview side-by-side:\n   - \\`grove preview <variant-a> <variant-b>\\`\n5. Summarize the differences and recommend a winner.\n\n## Tips\n\n- You can run Grove commands from any subdirectory; it finds the grove root automatically.\n- The \\`current\\` symlink points to the active tree.\n`;\n\nexport async function claudeSetup(options: ClaudeSetupOptions = {}): Promise<void> {\n  const cwd = process.cwd();\n  const out = getOutputOptions();\n  const spinner = shouldUseSpinner(out) ? ora('Setting up Claude integration...').start() : null;\n\n  try {\n    const groveRoot = await resolveGroveRoot(cwd);\n    const claudeDir = path.join(groveRoot, '.claude');\n    const skillsDir = path.join(claudeDir, 'skills');\n    const groveSkillDir = path.join(skillsDir, 'grove');\n    const skillPath = path.join(groveSkillDir, 'SKILL.md');\n    const settingsPath = path.join(claudeDir, 'settings.local.json');\n\n    const createSettings = options.settings !== false;\n    const dryRun = !!options.dryRun;\n    const force = !!options.force;\n\n    const skillExists = await fs.pathExists(skillPath);\n    const settingsExists = await fs.pathExists(settingsPath);\n\n    const actions: string[] = [];\n\n    if (!skillExists) {\n      actions.push(`create ${path.relative(groveRoot, skillPath)}`);\n    } else if (force) {\n      actions.push(`overwrite ${path.relative(groveRoot, skillPath)}`);\n    } else {\n      actions.push(`skip existing ${path.relative(groveRoot, skillPath)}`);\n    }\n\n    if (createSettings) {\n      if (!settingsExists) {\n        actions.push(`create ${path.relative(groveRoot, settingsPath)}`);\n      } else {\n        actions.push(`skip existing ${path.relative(groveRoot, settingsPath)}`);\n      }\n    } else {\n      actions.push('skip settings.local.json (disabled)');\n    }\n\n    if (dryRun) {\n      if (spinner) spinner.succeed('Dry run complete');\n      if (out.json) {\n        printJson({ ok: true, dryRun: true, actions });\n        return;\n      }\n      if (out.quiet) return;\n      console.log(chalk.gray('Dry run; no files written. Planned actions:'));\n      for (const a of actions) console.log(chalk.gray(`  - ${a}`));\n      return;\n    }\n\n    // Write skill\n    if (!skillExists || force) {\n      await fs.ensureDir(groveSkillDir);\n      await fs.writeFile(skillPath, DEFAULT_GROVE_SKILL_MD, 'utf-8');\n    }\n\n    // Write settings if missing (never overwrite)\n    if (createSettings && !settingsExists) {\n      await fs.ensureDir(claudeDir);\n      await fs.writeJson(\n        settingsPath,\n        { permissions: { allow: ['Bash(grove:*)'] } },\n        { spaces: 2 }\n      );\n    }\n\n    if (spinner) spinner.succeed('Claude integration ready');\n\n    if (out.json) {\n      printJson({ ok: true, dryRun: false, actions });\n      return;\n    }\n\n    if (out.quiet) return;\n\n    console.log('');\n    console.log(chalk.green('Claude integration created:'));\n    console.log(chalk.gray(`  Skill:     ${path.relative(groveRoot, skillPath)}`));\n    if (createSettings) {\n      if (!settingsExists) {\n        console.log(chalk.gray(`  Settings:  ${path.relative(groveRoot, settingsPath)}`));\n        console.log(chalk.gray(`            (allows Bash(grove:*))`));\n      } else {\n        console.log(chalk.yellow('  Settings:  already exists; not modified.'));\n        console.log(chalk.gray('            To allow Grove commands, add:'));\n        console.log(chalk.gray('            \"Bash(grove:*)\" to .claude/settings.local.json permissions.allow'));\n      }\n    }\n  } catch (error) {\n    if (spinner) spinner.fail('Failed to set up Claude integration');\n    const message = error instanceof Error ? error.message : String(error);\n    if (out.json) {\n      printJson({ ok: false, error: message });\n    } else if (!out.quiet) {\n      console.error(chalk.red(message));\n    }\n    process.exit(1);\n  }\n}\n\n"],"mappings":"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","names":["fs","path","execa","execa","fs","path","execa","fs","path","execa","fs","path","fs","path","path","fs","fs","path","chalk","ora","fs","path","path","fs","execa","fs","path","execa","fs","path","ora","chalk","chalk","preview","chalk","preview","chalk","ora","ora","chalk","chalk","ora","path","fs","ora","path","chalk","fs","chalk","ora","chalk","targets","preview","ora","chalk","ora","chalk","preview","chalk","chalk","ora","chalk","ora","chalk","chalk","chalk","execa","chalk","execa","chalk","ora","path","ora","path","chalk","chalk","ora","path","ora","path","chalk","chalk","ora","path","ora","path","preview","chalk","chalk","ora","path","fs","ora","path","fs","chalk"]}