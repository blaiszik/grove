{"version":3,"sources":["../src/index.ts","../src/commands/init.ts","../src/lib/config.ts","../src/types.ts","../src/lib/git.ts","../src/lib/deps.ts","../src/lib/framework.ts","../src/commands/plant.ts","../src/lib/symlink.ts","../src/lib/editor.ts","../src/commands/list.ts","../src/lib/preview.ts","../src/commands/tend.ts","../src/commands/uproot.ts","../src/commands/preview.ts","../src/commands/status.ts","../src/commands/open.ts","../src/commands/spawn.ts","../src/commands/path.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { program } from 'commander';\nimport { init } from './commands/init.js';\nimport { plant } from './commands/plant.js';\nimport { list } from './commands/list.js';\nimport { tend } from './commands/tend.js';\nimport { uproot } from './commands/uproot.js';\nimport { preview } from './commands/preview.js';\nimport { status } from './commands/status.js';\nimport { open } from './commands/open.js';\nimport { spawn } from './commands/spawn.js';\nimport { getPath } from './commands/path.js';\n\nprogram\n  .name('grove')\n  .description('Git worktree manager with smart dependency handling')\n  .version('1.0.0');\n\nprogram\n  .command('init')\n  .description('Initialize grove in current repository')\n  .action(init);\n\nprogram\n  .command('plant <branch> [name]')\n  .description('Create a new worktree (plant a tree)')\n  .option('-n, --new', 'Create a new branch')\n  .option('-b, --base <branch>', 'Base branch for new branch')\n  .option('--no-install', 'Skip dependency installation')\n  .option('-s, --switch', 'Switch to the new tree after creating')\n  .action(plant);\n\nprogram\n  .command('tend <name>')\n  .description('Switch to a worktree (tend to a tree)')\n  .action(tend);\n\nprogram\n  .command('list')\n  .alias('ls')\n  .description('List all trees in the grove')\n  .action(list);\n\nprogram\n  .command('uproot <name>')\n  .description('Remove a worktree')\n  .option('-f, --force', 'Force removal even with uncommitted changes')\n  .action(uproot);\n\n// AI Coding Tool Integration\nprogram\n  .command('open <name>')\n  .description('Open a worktree in Cursor, VS Code, or other editor')\n  .option('-e, --editor <editor>', 'Specify editor (cursor, code, zed)')\n  .action(open);\n\nprogram\n  .command('spawn <name>')\n  .description('Start an interactive Claude Code session in a worktree')\n  .action(spawn);\n\nprogram\n  .command('path <name>')\n  .description('Print the path to a worktree (for shell integration)')\n  .action(getPath);\n\n// Preview & Status\nprogram\n  .command('preview <action> [name]')\n  .description('Start/stop preview server (action: tree name or \"stop\")')\n  .option('-d, --dev', 'Run in development mode (default)')\n  .option('-b, --build', 'Build and serve in production mode')\n  .action(preview);\n\nprogram\n  .command('status')\n  .description('Show grove status and running previews')\n  .action(status);\n\n// Add some helpful examples\nprogram.addHelpText('after', `\n\nExamples:\n  $ grove init                    Initialize grove in current repo\n  $ grove plant feature-x         Create worktree for existing branch\n  $ grove plant -n my-feature     Create worktree with new branch\n\n  AI Coding Workflows:\n  $ grove open feature-x          Open in Cursor (or VS Code)\n  $ grove spawn feature-x         Start Claude Code in worktree\n  $ cd $(grove path feature-x)    Navigate to worktree in shell\n\n  Management:\n  $ grove list                    List all trees\n  $ grove tend feature-x          Switch current symlink\n  $ grove preview feature-x       Start dev server\n  $ grove uproot feature-x        Remove worktree\n\nThe 'current' symlink always points to the active tree.\n\nShell Integration:\n  Add to your .zshrc or .bashrc:\n\n  # Quick cd to grove tree\n  gcd() { cd \"$(grove path \"$1\")\"; }\n`);\n\nprogram.parse();\n","import fs from 'fs-extra';\nimport path from 'path';\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport {\n  getGroveDir,\n  getTreesDir,\n  getSharedDir,\n  groveExists,\n  writeConfig,\n  createDefaultConfig,\n} from '../lib/config.js';\nimport { isGitRepo, getRepoRoot, getCurrentBranch, createWorktree } from '../lib/git.js';\nimport { detectPackageManager } from '../lib/deps.js';\nimport { detectFramework } from '../lib/framework.js';\nimport { createCurrentLink } from '../lib/symlink.js';\nimport { GROVE_DIR } from '../types.js';\n\nexport async function init(): Promise<void> {\n  const cwd = process.cwd();\n\n  // Check if already initialized\n  if (await groveExists(cwd)) {\n    console.log(chalk.yellow('Grove is already initialized in this directory.'));\n    return;\n  }\n\n  // Check if in a git repo\n  if (!(await isGitRepo(cwd))) {\n    console.log(chalk.red('Error: Not a git repository.'));\n    console.log(chalk.gray('Run this command from within a git repository.'));\n    process.exit(1);\n  }\n\n  const spinner = ora('Initializing grove...').start();\n\n  try {\n    const repoRoot = await getRepoRoot(cwd);\n    const currentBranch = await getCurrentBranch(cwd);\n\n    // Create directory structure\n    const groveDir = getGroveDir(cwd);\n    const treesDir = getTreesDir(cwd);\n    const sharedDir = getSharedDir(cwd);\n\n    await fs.ensureDir(groveDir);\n    await fs.ensureDir(treesDir);\n    await fs.ensureDir(sharedDir);\n\n    // Detect project configuration\n    spinner.text = 'Detecting project configuration...';\n    const packageManager = await detectPackageManager(cwd);\n    const framework = await detectFramework(cwd);\n\n    // Create initial config\n    const config = createDefaultConfig(repoRoot);\n    config.packageManager = packageManager;\n    config.framework = framework;\n\n    // Register the main repo directory as the \"main\" tree\n    // We don't create a worktree here because the current branch is already checked out\n    // in the main repo. Users can create worktrees for other branches with `grove plant`.\n    const mainTreeName = 'main';\n    config.trees[mainTreeName] = {\n      branch: currentBranch,\n      path: repoRoot, // Point to the actual repo, not a worktree\n      created: new Date().toISOString(),\n    };\n    config.current = mainTreeName;\n\n    // Save config\n    await writeConfig(config, cwd);\n\n    // Create current symlink pointing to the repo root\n    // Using relative path for the symlink\n    const currentLinkPath = path.join(cwd, 'current');\n    if (await fs.pathExists(currentLinkPath)) {\n      await fs.remove(currentLinkPath);\n    }\n    await fs.symlink('.', currentLinkPath);\n\n    // Add .grove to .gitignore if not already present\n    const gitignorePath = path.join(cwd, '.gitignore');\n    if (await fs.pathExists(gitignorePath)) {\n      const gitignore = await fs.readFile(gitignorePath, 'utf-8');\n      if (!gitignore.includes(GROVE_DIR)) {\n        await fs.appendFile(gitignorePath, `\\n# Grove worktree manager\\n${GROVE_DIR}/\\ncurrent\\n`);\n      }\n    } else {\n      await fs.writeFile(gitignorePath, `# Grove worktree manager\\n${GROVE_DIR}/\\ncurrent\\n`);\n    }\n\n    spinner.succeed('Grove initialized!');\n\n    console.log('');\n    console.log(chalk.green('Created:'));\n    console.log(chalk.gray(`  ${GROVE_DIR}/              Configuration directory`));\n    console.log(chalk.gray(`  ${GROVE_DIR}/trees/        Worktree storage`));\n    console.log(chalk.gray(`  current              Symlink to active tree`));\n    console.log('');\n    console.log(chalk.blue('Detected:'));\n    console.log(chalk.gray(`  Package manager: ${packageManager}`));\n    console.log(chalk.gray(`  Framework: ${framework}`));\n    console.log('');\n    console.log(chalk.cyan('Next steps:'));\n    console.log(chalk.gray(`  grove plant <branch>     Create a new worktree`));\n    console.log(chalk.gray(`  grove list               List all trees`));\n    console.log(chalk.gray(`  grove tend <name>        Switch to a tree`));\n  } catch (error) {\n    spinner.fail('Failed to initialize grove');\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    process.exit(1);\n  }\n}\n","import fs from 'fs-extra';\nimport path from 'path';\nimport {\n  GroveConfig,\n  GROVE_DIR,\n  GROVE_CONFIG,\n  GROVE_TREES,\n  GROVE_SHARED,\n} from '../types.js';\n\nexport function getGroveDir(cwd: string = process.cwd()): string {\n  return path.join(cwd, GROVE_DIR);\n}\n\nexport function getConfigPath(cwd: string = process.cwd()): string {\n  return path.join(getGroveDir(cwd), GROVE_CONFIG);\n}\n\nexport function getTreesDir(cwd: string = process.cwd()): string {\n  return path.join(getGroveDir(cwd), GROVE_TREES);\n}\n\nexport function getSharedDir(cwd: string = process.cwd()): string {\n  return path.join(getGroveDir(cwd), GROVE_SHARED);\n}\n\nexport function getTreePath(name: string, cwd: string = process.cwd()): string {\n  return path.join(getTreesDir(cwd), name);\n}\n\nexport async function groveExists(cwd: string = process.cwd()): Promise<boolean> {\n  return fs.pathExists(getConfigPath(cwd));\n}\n\nexport async function readConfig(cwd: string = process.cwd()): Promise<GroveConfig> {\n  const configPath = getConfigPath(cwd);\n  if (!(await fs.pathExists(configPath))) {\n    throw new Error('Grove not initialized. Run `grove init` first.');\n  }\n  return fs.readJson(configPath);\n}\n\nexport async function writeConfig(\n  config: GroveConfig,\n  cwd: string = process.cwd()\n): Promise<void> {\n  const configPath = getConfigPath(cwd);\n  await fs.writeJson(configPath, config, { spaces: 2 });\n}\n\nexport async function updateConfig(\n  updater: (config: GroveConfig) => GroveConfig | Promise<GroveConfig>,\n  cwd: string = process.cwd()\n): Promise<GroveConfig> {\n  const config = await readConfig(cwd);\n  const updated = await updater(config);\n  await writeConfig(updated, cwd);\n  return updated;\n}\n\nexport function createDefaultConfig(repo: string): GroveConfig {\n  return {\n    version: 1,\n    repo,\n    packageManager: 'npm',\n    framework: 'generic',\n    trees: {},\n    current: null,\n    previews: {},\n  };\n}\n","export type PackageManager = 'pnpm' | 'npm' | 'yarn';\nexport type Framework = 'nextjs' | 'vite' | 'cra' | 'generic';\n\nexport interface TreeInfo {\n  branch: string;\n  path: string;\n  created: string;\n}\n\nexport interface PreviewInfo {\n  pid: number;\n  port: number;\n  mode: 'dev' | 'build';\n  startedAt: string;\n}\n\nexport interface GroveConfig {\n  version: 1;\n  repo: string;\n  packageManager: PackageManager;\n  framework: Framework;\n  trees: Record<string, TreeInfo>;\n  current: string | null;\n  previews: Record<string, PreviewInfo>;\n}\n\nexport interface DetectedProject {\n  packageManager: PackageManager;\n  framework: Framework;\n  hasPackageJson: boolean;\n  lockfile: string | null;\n}\n\nexport const GROVE_DIR = '.grove';\nexport const GROVE_CONFIG = 'config.json';\nexport const GROVE_TREES = 'trees';\nexport const GROVE_SHARED = 'shared';\nexport const CURRENT_LINK = 'current';\n","import { execa } from 'execa';\nimport path from 'path';\n\nexport interface GitWorktree {\n  path: string;\n  head: string;\n  branch: string | null;\n}\n\nexport async function isGitRepo(cwd: string = process.cwd()): Promise<boolean> {\n  try {\n    await execa('git', ['rev-parse', '--git-dir'], { cwd });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function getRepoRoot(cwd: string = process.cwd()): Promise<string> {\n  const { stdout } = await execa('git', ['rev-parse', '--show-toplevel'], { cwd });\n  return stdout.trim();\n}\n\nexport async function getCurrentBranch(cwd: string = process.cwd()): Promise<string> {\n  const { stdout } = await execa('git', ['rev-parse', '--abbrev-ref', 'HEAD'], { cwd });\n  return stdout.trim();\n}\n\nexport async function branchExists(branch: string, cwd: string = process.cwd()): Promise<boolean> {\n  try {\n    await execa('git', ['rev-parse', '--verify', branch], { cwd });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function remoteBranchExists(branch: string, cwd: string = process.cwd()): Promise<boolean> {\n  try {\n    await execa('git', ['rev-parse', '--verify', `origin/${branch}`], { cwd });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function createWorktree(\n  targetPath: string,\n  branch: string,\n  options: { createBranch?: boolean; baseBranch?: string } = {},\n  cwd: string = process.cwd()\n): Promise<void> {\n  const args = ['worktree', 'add'];\n\n  if (options.createBranch) {\n    args.push('-b', branch);\n    args.push(targetPath);\n    if (options.baseBranch) {\n      args.push(options.baseBranch);\n    }\n  } else {\n    args.push(targetPath, branch);\n  }\n\n  await execa('git', args, { cwd });\n}\n\nexport async function removeWorktree(\n  targetPath: string,\n  options: { force?: boolean } = {},\n  cwd: string = process.cwd()\n): Promise<void> {\n  const args = ['worktree', 'remove'];\n  if (options.force) {\n    args.push('--force');\n  }\n  args.push(targetPath);\n\n  await execa('git', args, { cwd });\n}\n\nexport async function listWorktrees(cwd: string = process.cwd()): Promise<GitWorktree[]> {\n  const { stdout } = await execa('git', ['worktree', 'list', '--porcelain'], { cwd });\n  const worktrees: GitWorktree[] = [];\n  let current: Partial<GitWorktree> = {};\n\n  for (const line of stdout.split('\\n')) {\n    if (line.startsWith('worktree ')) {\n      current.path = line.slice(9);\n    } else if (line.startsWith('HEAD ')) {\n      current.head = line.slice(5);\n    } else if (line.startsWith('branch ')) {\n      current.branch = line.slice(7).replace('refs/heads/', '');\n    } else if (line === 'detached') {\n      current.branch = null;\n    } else if (line === '') {\n      if (current.path && current.head !== undefined) {\n        worktrees.push(current as GitWorktree);\n      }\n      current = {};\n    }\n  }\n\n  // Handle last entry if no trailing newline\n  if (current.path && current.head !== undefined) {\n    worktrees.push(current as GitWorktree);\n  }\n\n  return worktrees;\n}\n\nexport async function fetchBranch(branch: string, cwd: string = process.cwd()): Promise<void> {\n  await execa('git', ['fetch', 'origin', branch], { cwd });\n}\n\nexport async function getGitDir(cwd: string = process.cwd()): Promise<string> {\n  const { stdout } = await execa('git', ['rev-parse', '--git-dir'], { cwd });\n  const gitDir = stdout.trim();\n  return path.isAbsolute(gitDir) ? gitDir : path.join(cwd, gitDir);\n}\n","import fs from 'fs-extra';\nimport path from 'path';\nimport { execa } from 'execa';\nimport crypto from 'crypto';\nimport { PackageManager } from '../types.js';\nimport { getSharedDir } from './config.js';\n\nexport interface LockfileInfo {\n  type: PackageManager;\n  path: string;\n  hash: string;\n}\n\nconst LOCKFILES: Record<string, PackageManager> = {\n  'pnpm-lock.yaml': 'pnpm',\n  'yarn.lock': 'yarn',\n  'package-lock.json': 'npm',\n};\n\nexport async function detectPackageManager(\n  cwd: string = process.cwd()\n): Promise<PackageManager> {\n  // Check for lockfiles in order of preference\n  for (const [filename, manager] of Object.entries(LOCKFILES)) {\n    if (await fs.pathExists(path.join(cwd, filename))) {\n      return manager;\n    }\n  }\n  return 'npm';\n}\n\nexport async function getLockfileInfo(\n  cwd: string = process.cwd()\n): Promise<LockfileInfo | null> {\n  for (const [filename, manager] of Object.entries(LOCKFILES)) {\n    const lockfilePath = path.join(cwd, filename);\n    if (await fs.pathExists(lockfilePath)) {\n      const content = await fs.readFile(lockfilePath);\n      const hash = crypto.createHash('sha256').update(content).digest('hex');\n      return { type: manager, path: lockfilePath, hash };\n    }\n  }\n  return null;\n}\n\nexport async function installDependencies(\n  manager: PackageManager,\n  targetDir: string,\n  options: { useSharedStore?: boolean; groveDir?: string } = {}\n): Promise<void> {\n  const args: string[] = ['install'];\n\n  if (manager === 'pnpm' && options.useSharedStore && options.groveDir) {\n    const storePath = path.join(getSharedDir(options.groveDir), 'pnpm-store');\n    await fs.ensureDir(storePath);\n    args.push('--store-dir', storePath);\n  }\n\n  // Add flags for cleaner output\n  if (manager === 'npm') {\n    args.push('--prefer-offline');\n  } else if (manager === 'yarn') {\n    args.push('--prefer-offline');\n  } else if (manager === 'pnpm') {\n    args.push('--prefer-offline');\n  }\n\n  await execa(manager, args, {\n    cwd: targetDir,\n    stdio: 'inherit',\n  });\n}\n\nexport async function canSymlinkNodeModules(\n  sourceDir: string,\n  targetDir: string\n): Promise<boolean> {\n  const sourceLockfile = await getLockfileInfo(sourceDir);\n  const targetLockfile = await getLockfileInfo(targetDir);\n\n  if (!sourceLockfile || !targetLockfile) {\n    return false;\n  }\n\n  // Can only symlink if same package manager and same lockfile hash\n  return (\n    sourceLockfile.type === targetLockfile.type &&\n    sourceLockfile.hash === targetLockfile.hash\n  );\n}\n\nexport async function symlinkNodeModules(\n  sourceDir: string,\n  targetDir: string\n): Promise<void> {\n  const sourceModules = path.join(sourceDir, 'node_modules');\n  const targetModules = path.join(targetDir, 'node_modules');\n\n  if (!(await fs.pathExists(sourceModules))) {\n    throw new Error(`Source node_modules not found: ${sourceModules}`);\n  }\n\n  // Remove existing node_modules in target if present\n  if (await fs.pathExists(targetModules)) {\n    await fs.remove(targetModules);\n  }\n\n  // Create relative symlink\n  const relativePath = path.relative(targetDir, sourceModules);\n  await fs.symlink(relativePath, targetModules);\n}\n\nexport async function copyLockfile(\n  sourceDir: string,\n  targetDir: string,\n  manager: PackageManager\n): Promise<void> {\n  const lockfileName = Object.entries(LOCKFILES).find(\n    ([, m]) => m === manager\n  )?.[0];\n\n  if (!lockfileName) return;\n\n  const sourcePath = path.join(sourceDir, lockfileName);\n  const targetPath = path.join(targetDir, lockfileName);\n\n  if (await fs.pathExists(sourcePath)) {\n    await fs.copy(sourcePath, targetPath);\n  }\n}\n\nexport async function hasNodeModules(dir: string): Promise<boolean> {\n  return fs.pathExists(path.join(dir, 'node_modules'));\n}\n","import fs from 'fs-extra';\nimport path from 'path';\nimport { Framework } from '../types.js';\n\ninterface FrameworkConfig {\n  devCommand: string;\n  buildCommand: string;\n  serveCommand: string;\n  defaultPort: number;\n  cacheDir: string | null;\n}\n\nexport const FRAMEWORK_CONFIGS: Record<Framework, FrameworkConfig> = {\n  nextjs: {\n    devCommand: 'next dev',\n    buildCommand: 'next build',\n    serveCommand: 'next start',\n    defaultPort: 3000,\n    cacheDir: '.next',\n  },\n  vite: {\n    devCommand: 'vite',\n    buildCommand: 'vite build',\n    serveCommand: 'vite preview',\n    defaultPort: 5173,\n    cacheDir: '.vite',\n  },\n  cra: {\n    devCommand: 'react-scripts start',\n    buildCommand: 'react-scripts build',\n    serveCommand: 'serve -s build',\n    defaultPort: 3000,\n    cacheDir: null,\n  },\n  generic: {\n    devCommand: 'npm run dev',\n    buildCommand: 'npm run build',\n    serveCommand: 'npm run start',\n    defaultPort: 3000,\n    cacheDir: null,\n  },\n};\n\nexport async function detectFramework(cwd: string = process.cwd()): Promise<Framework> {\n  const packageJsonPath = path.join(cwd, 'package.json');\n\n  if (!(await fs.pathExists(packageJsonPath))) {\n    return 'generic';\n  }\n\n  try {\n    const pkg = await fs.readJson(packageJsonPath);\n    const deps = {\n      ...pkg.dependencies,\n      ...pkg.devDependencies,\n    };\n\n    // Check for Next.js\n    if (deps.next) {\n      return 'nextjs';\n    }\n\n    // Check for Vite\n    if (deps.vite) {\n      return 'vite';\n    }\n\n    // Check for Create React App\n    if (deps['react-scripts']) {\n      return 'cra';\n    }\n\n    return 'generic';\n  } catch {\n    return 'generic';\n  }\n}\n\nexport function getFrameworkConfig(framework: Framework): FrameworkConfig {\n  return FRAMEWORK_CONFIGS[framework];\n}\n\nexport async function getDevCommand(cwd: string = process.cwd()): Promise<string> {\n  const packageJsonPath = path.join(cwd, 'package.json');\n\n  if (await fs.pathExists(packageJsonPath)) {\n    try {\n      const pkg = await fs.readJson(packageJsonPath);\n      if (pkg.scripts?.dev) {\n        return 'npm run dev';\n      }\n      if (pkg.scripts?.start) {\n        return 'npm run start';\n      }\n    } catch {\n      // Fall through to framework detection\n    }\n  }\n\n  const framework = await detectFramework(cwd);\n  return FRAMEWORK_CONFIGS[framework].devCommand;\n}\n\nexport async function getBuildCommand(cwd: string = process.cwd()): Promise<string> {\n  const packageJsonPath = path.join(cwd, 'package.json');\n\n  if (await fs.pathExists(packageJsonPath)) {\n    try {\n      const pkg = await fs.readJson(packageJsonPath);\n      if (pkg.scripts?.build) {\n        return 'npm run build';\n      }\n    } catch {\n      // Fall through to framework detection\n    }\n  }\n\n  const framework = await detectFramework(cwd);\n  return FRAMEWORK_CONFIGS[framework].buildCommand;\n}\n\nexport async function getServeCommand(cwd: string = process.cwd()): Promise<string> {\n  const packageJsonPath = path.join(cwd, 'package.json');\n\n  if (await fs.pathExists(packageJsonPath)) {\n    try {\n      const pkg = await fs.readJson(packageJsonPath);\n      if (pkg.scripts?.start) {\n        return 'npm run start';\n      }\n      if (pkg.scripts?.serve) {\n        return 'npm run serve';\n      }\n    } catch {\n      // Fall through to framework detection\n    }\n  }\n\n  const framework = await detectFramework(cwd);\n  return FRAMEWORK_CONFIGS[framework].serveCommand;\n}\n\nexport async function clearFrameworkCache(\n  cwd: string,\n  framework: Framework\n): Promise<void> {\n  const config = FRAMEWORK_CONFIGS[framework];\n  if (config.cacheDir) {\n    const cachePath = path.join(cwd, config.cacheDir);\n    if (await fs.pathExists(cachePath)) {\n      await fs.remove(cachePath);\n    }\n  }\n}\n","import path from 'path';\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport { readConfig, updateConfig, getTreePath, getGroveDir } from '../lib/config.js';\nimport {\n  branchExists,\n  remoteBranchExists,\n  createWorktree,\n  fetchBranch,\n} from '../lib/git.js';\nimport {\n  detectPackageManager,\n  installDependencies,\n  canSymlinkNodeModules,\n  symlinkNodeModules,\n  hasNodeModules,\n} from '../lib/deps.js';\nimport { createCurrentLink } from '../lib/symlink.js';\nimport { copyEditorConfigs } from '../lib/editor.js';\n\ninterface PlantOptions {\n  new?: boolean;\n  base?: string;\n  install?: boolean;\n  switch?: boolean;\n}\n\nexport async function plant(\n  branch: string,\n  name: string | undefined,\n  options: PlantOptions\n): Promise<void> {\n  const cwd = process.cwd();\n  const treeName = name || branch.replace(/\\//g, '-');\n\n  const spinner = ora(`Planting tree '${treeName}'...`).start();\n\n  try {\n    const config = await readConfig(cwd);\n\n    // Check if tree already exists\n    if (config.trees[treeName]) {\n      spinner.fail(`Tree '${treeName}' already exists`);\n      console.log(chalk.gray(`Use 'grove tend ${treeName}' to switch to it.`));\n      process.exit(1);\n    }\n\n    // Determine if we need to create a new branch\n    const localExists = await branchExists(branch, config.repo);\n    const remoteExists = await remoteBranchExists(branch, config.repo);\n    const shouldCreate = options.new || (!localExists && !remoteExists);\n\n    if (!localExists && remoteExists && !options.new) {\n      spinner.text = `Fetching branch '${branch}' from origin...`;\n      await fetchBranch(branch, config.repo);\n    }\n\n    // Create the worktree\n    spinner.text = `Creating worktree for '${branch}'...`;\n    const treePath = getTreePath(treeName, cwd);\n\n    await createWorktree(\n      treePath,\n      branch,\n      {\n        createBranch: shouldCreate,\n        baseBranch: options.base,\n      },\n      config.repo\n    );\n\n    // Copy editor/AI tool configurations from repo root\n    spinner.text = 'Copying editor configurations...';\n    const copiedConfigs = await copyEditorConfigs(config.repo, treePath);\n    if (copiedConfigs.length > 0) {\n      spinner.text = `Copied: ${copiedConfigs.join(', ')}`;\n    }\n\n    // Handle dependencies\n    const shouldInstall = options.install !== false; // Default to true\n    if (shouldInstall) {\n      spinner.text = 'Setting up dependencies...';\n\n      // Find an existing tree with node_modules\n      let sourceTree: string | null = null;\n      for (const [existingName, tree] of Object.entries(config.trees)) {\n        if (await hasNodeModules(tree.path)) {\n          sourceTree = existingName;\n          break;\n        }\n      }\n\n      const manager = await detectPackageManager(treePath);\n\n      if (manager === 'pnpm') {\n        // pnpm: always install with shared store\n        spinner.text = 'Installing dependencies with shared pnpm store...';\n        await installDependencies(manager, treePath, {\n          useSharedStore: true,\n          groveDir: cwd,\n        });\n      } else if (sourceTree) {\n        // npm/yarn: try to symlink if lockfiles match\n        const sourceTreePath = config.trees[sourceTree].path;\n        const canSymlink = await canSymlinkNodeModules(sourceTreePath, treePath);\n\n        if (canSymlink) {\n          spinner.text = `Symlinking node_modules from '${sourceTree}'...`;\n          await symlinkNodeModules(sourceTreePath, treePath);\n        } else {\n          spinner.text = 'Installing dependencies...';\n          await installDependencies(manager, treePath);\n        }\n      } else {\n        // No existing tree with node_modules, fresh install\n        spinner.text = 'Installing dependencies...';\n        await installDependencies(manager, treePath);\n      }\n    }\n\n    // Register the tree\n    await updateConfig((c) => ({\n      ...c,\n      trees: {\n        ...c.trees,\n        [treeName]: {\n          branch,\n          path: treePath,\n          created: new Date().toISOString(),\n        },\n      },\n    }), cwd);\n\n    // Optionally switch to the new tree\n    if (options.switch) {\n      await createCurrentLink(treeName, cwd);\n      await updateConfig((c) => ({\n        ...c,\n        current: treeName,\n      }), cwd);\n    }\n\n    spinner.succeed(`Planted tree '${treeName}'`);\n\n    console.log('');\n    console.log(chalk.green('Tree details:'));\n    console.log(chalk.gray(`  Name:   ${treeName}`));\n    console.log(chalk.gray(`  Branch: ${branch}`));\n    console.log(chalk.gray(`  Path:   ${treePath}`));\n    console.log('');\n\n    if (copiedConfigs.length > 0) {\n      console.log(chalk.blue('Copied configs:'));\n      console.log(chalk.gray(`  ${copiedConfigs.join(', ')}`));\n      console.log('');\n    }\n\n    if (options.switch) {\n      console.log(chalk.cyan(`Switched to '${treeName}'`));\n    } else {\n      console.log(chalk.cyan('Next steps:'));\n      console.log(chalk.gray(`  grove open ${treeName}        Open in Cursor/VS Code`));\n      console.log(chalk.gray(`  grove spawn ${treeName}       Start Claude Code session`));\n      console.log(chalk.gray(`  grove tend ${treeName}        Switch current symlink`));\n    }\n  } catch (error) {\n    spinner.fail('Failed to plant tree');\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    process.exit(1);\n  }\n}\n","import fs from 'fs-extra';\nimport path from 'path';\nimport { CURRENT_LINK } from '../types.js';\nimport { getTreePath, readConfig } from './config.js';\n\nexport function getCurrentLinkPath(cwd: string = process.cwd()): string {\n  return path.join(cwd, CURRENT_LINK);\n}\n\nexport async function createCurrentLink(\n  treeName: string,\n  cwd: string = process.cwd()\n): Promise<void> {\n  const linkPath = getCurrentLinkPath(cwd);\n  const targetPath = getTreePath(treeName, cwd);\n\n  // Remove existing symlink if present\n  if (await fs.pathExists(linkPath)) {\n    await fs.remove(linkPath);\n  }\n\n  // Create relative symlink\n  const relativePath = path.relative(cwd, targetPath);\n  await fs.symlink(relativePath, linkPath);\n}\n\nexport async function removeCurrentLink(cwd: string = process.cwd()): Promise<void> {\n  const linkPath = getCurrentLinkPath(cwd);\n  if (await fs.pathExists(linkPath)) {\n    await fs.remove(linkPath);\n  }\n}\n\nexport async function getCurrentTreeName(cwd: string = process.cwd()): Promise<string | null> {\n  const linkPath = getCurrentLinkPath(cwd);\n\n  try {\n    const target = await fs.readlink(linkPath);\n\n    // Handle special case where symlink points to '.' (main repo)\n    if (target === '.') {\n      // Find the tree that points to the repo root\n      const config = await readConfig(cwd);\n      for (const [name, tree] of Object.entries(config.trees)) {\n        // The main tree path is the repo root (cwd after normalization)\n        const normalizedTreePath = path.resolve(tree.path);\n        const normalizedCwd = path.resolve(cwd);\n        if (normalizedTreePath === normalizedCwd) {\n          return name;\n        }\n      }\n      return null;\n    }\n\n    // Extract tree name from path like .grove/trees/main\n    const parts = target.split(path.sep);\n    return parts[parts.length - 1];\n  } catch {\n    return null;\n  }\n}\n\nexport async function isSymlinkValid(cwd: string = process.cwd()): Promise<boolean> {\n  const linkPath = getCurrentLinkPath(cwd);\n\n  try {\n    const stat = await fs.lstat(linkPath);\n    if (!stat.isSymbolicLink()) {\n      return false;\n    }\n    // Check if target exists\n    await fs.stat(linkPath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { execa } from 'execa';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport { getTreePath, readConfig } from './config.js';\n\nexport type Editor = 'cursor' | 'code' | 'claude' | 'zed';\n\ninterface EditorConfig {\n  command: string;\n  args: string[];\n  name: string;\n}\n\nconst EDITORS: Record<Editor, EditorConfig> = {\n  cursor: {\n    command: 'cursor',\n    args: ['.'],\n    name: 'Cursor',\n  },\n  code: {\n    command: 'code',\n    args: ['.'],\n    name: 'VS Code',\n  },\n  claude: {\n    command: 'claude',\n    args: [],\n    name: 'Claude Code',\n  },\n  zed: {\n    command: 'zed',\n    args: ['.'],\n    name: 'Zed',\n  },\n};\n\nexport async function detectAvailableEditors(): Promise<Editor[]> {\n  const available: Editor[] = [];\n\n  for (const [name, config] of Object.entries(EDITORS)) {\n    try {\n      await execa('which', [config.command]);\n      available.push(name as Editor);\n    } catch {\n      // Editor not available\n    }\n  }\n\n  return available;\n}\n\nexport async function openInEditor(\n  treeName: string,\n  editor: Editor,\n  cwd: string = process.cwd()\n): Promise<void> {\n  const treePath = getTreePath(treeName, cwd);\n  const config = EDITORS[editor];\n\n  if (!config) {\n    throw new Error(`Unknown editor: ${editor}`);\n  }\n\n  // Verify tree exists\n  if (!(await fs.pathExists(treePath))) {\n    throw new Error(`Tree path does not exist: ${treePath}`);\n  }\n\n  // Launch editor in the worktree directory\n  await execa(config.command, config.args, {\n    cwd: treePath,\n    detached: true,\n    stdio: 'ignore',\n  });\n}\n\nexport async function spawnClaudeCode(\n  treeName: string,\n  cwd: string = process.cwd()\n): Promise<void> {\n  const treePath = getTreePath(treeName, cwd);\n\n  // Verify tree exists\n  if (!(await fs.pathExists(treePath))) {\n    throw new Error(`Tree path does not exist: ${treePath}`);\n  }\n\n  // Spawn Claude Code in a new session\n  // Using --yes to auto-accept any prompts\n  const child = execa('claude', [], {\n    cwd: treePath,\n    stdio: 'inherit',\n  });\n\n  // Wait for it to complete (interactive session)\n  await child;\n}\n\n// Files/directories to copy from the source repo to new worktrees\n// These are tool-specific configurations that should be preserved\nconst CONFIG_DIRS_TO_COPY = [\n  '.claude',           // Claude Code settings\n  '.cursor',           // Cursor settings\n  '.vscode',           // VS Code settings\n  '.zed',              // Zed settings\n  '.idea',             // JetBrains settings\n];\n\nconst CONFIG_FILES_TO_COPY = [\n  '.cursorrules',      // Cursor rules\n  '.clauderules',      // Claude rules (if exists)\n  'CLAUDE.md',         // Claude context file\n  'cursor.json',       // Cursor config\n];\n\nexport async function copyEditorConfigs(\n  sourceDir: string,\n  targetDir: string\n): Promise<string[]> {\n  const copied: string[] = [];\n\n  // Copy config directories\n  for (const dir of CONFIG_DIRS_TO_COPY) {\n    const sourcePath = path.join(sourceDir, dir);\n    const targetPath = path.join(targetDir, dir);\n\n    if (await fs.pathExists(sourcePath)) {\n      await fs.copy(sourcePath, targetPath, { overwrite: false });\n      copied.push(dir);\n    }\n  }\n\n  // Copy config files\n  for (const file of CONFIG_FILES_TO_COPY) {\n    const sourcePath = path.join(sourceDir, file);\n    const targetPath = path.join(targetDir, file);\n\n    if (await fs.pathExists(sourcePath)) {\n      await fs.copy(sourcePath, targetPath, { overwrite: false });\n      copied.push(file);\n    }\n  }\n\n  return copied;\n}\n\nexport function getEditorName(editor: Editor): string {\n  return EDITORS[editor]?.name || editor;\n}\n\nexport function getSupportedEditors(): Editor[] {\n  return Object.keys(EDITORS) as Editor[];\n}\n","import chalk from 'chalk';\nimport { readConfig } from '../lib/config.js';\nimport { getCurrentTreeName, isSymlinkValid } from '../lib/symlink.js';\nimport { isPreviewRunning, getRunningPreviews } from '../lib/preview.js';\n\nexport async function list(): Promise<void> {\n  const cwd = process.cwd();\n\n  try {\n    const config = await readConfig(cwd);\n    const currentTree = await getCurrentTreeName(cwd);\n    const previews = await getRunningPreviews(cwd);\n\n    const trees = Object.entries(config.trees);\n\n    if (trees.length === 0) {\n      console.log(chalk.yellow('No trees in the grove.'));\n      console.log(chalk.gray('Run `grove plant <branch>` to create one.'));\n      return;\n    }\n\n    console.log(chalk.bold('\\nGrove Trees:\\n'));\n\n    const maxNameLen = Math.max(...trees.map(([name]) => name.length));\n    const maxBranchLen = Math.max(...trees.map(([, info]) => info.branch.length));\n\n    for (const [name, info] of trees) {\n      const isCurrent = name === currentTree;\n      const preview = previews[name];\n      const isRunning = preview ? await isPreviewRunning(name, cwd) : false;\n\n      const marker = isCurrent ? chalk.green('â–¸ ') : '  ';\n      const nameStr = isCurrent\n        ? chalk.green(name.padEnd(maxNameLen))\n        : chalk.white(name.padEnd(maxNameLen));\n      const branchStr = chalk.gray(info.branch.padEnd(maxBranchLen));\n\n      let statusStr = '';\n      if (isRunning && preview) {\n        statusStr = chalk.cyan(` [preview :${preview.port}]`);\n      }\n\n      console.log(`${marker}${nameStr}  ${branchStr}${statusStr}`);\n    }\n\n    console.log('');\n    console.log(chalk.gray(`Package manager: ${config.packageManager}`));\n    console.log(chalk.gray(`Framework: ${config.framework}`));\n    console.log('');\n  } catch (error) {\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    process.exit(1);\n  }\n}\n","import { execa, type ExecaChildProcess } from 'execa';\nimport detectPort from 'detect-port';\nimport treeKill from 'tree-kill';\nimport { PreviewInfo } from '../types.js';\nimport { readConfig, updateConfig, getTreePath } from './config.js';\nimport { getDevCommand, getBuildCommand, getServeCommand, FRAMEWORK_CONFIGS } from './framework.js';\n\nconst runningProcesses: Map<string, ExecaChildProcess> = new Map();\n\nexport async function findAvailablePort(startPort: number = 3000): Promise<number> {\n  return detectPort(startPort);\n}\n\nexport async function startPreview(\n  treeName: string,\n  mode: 'dev' | 'build',\n  cwd: string = process.cwd()\n): Promise<PreviewInfo> {\n  const config = await readConfig(cwd);\n  const tree = config.trees[treeName];\n\n  if (!tree) {\n    throw new Error(`Tree '${treeName}' not found`);\n  }\n\n  // Check if already running\n  if (config.previews[treeName]) {\n    throw new Error(\n      `Preview for '${treeName}' is already running on port ${config.previews[treeName].port}`\n    );\n  }\n\n  const treePath = getTreePath(treeName, cwd);\n  const defaultPort = FRAMEWORK_CONFIGS[config.framework].defaultPort;\n  const port = await findAvailablePort(defaultPort);\n\n  let command: string;\n  let args: string[];\n\n  if (mode === 'dev') {\n    const devCmd = await getDevCommand(treePath);\n    const parts = devCmd.split(' ');\n    command = parts[0];\n    args = [...parts.slice(1), '--port', String(port)];\n  } else {\n    // Build first, then serve\n    const buildCmd = await getBuildCommand(treePath);\n    const buildParts = buildCmd.split(' ');\n    await execa(buildParts[0], buildParts.slice(1), {\n      cwd: treePath,\n      stdio: 'inherit',\n    });\n\n    const serveCmd = await getServeCommand(treePath);\n    const serveParts = serveCmd.split(' ');\n    command = serveParts[0];\n    args = [...serveParts.slice(1), '--port', String(port)];\n  }\n\n  // Start the process\n  const child = execa(command, args, {\n    cwd: treePath,\n    stdio: 'inherit',\n    detached: true,\n  });\n\n  // Don't await - let it run in background\n  child.catch(() => {\n    // Process ended - clean up config\n    cleanupPreview(treeName, cwd).catch(() => {});\n  });\n\n  const pid = child.pid!;\n  runningProcesses.set(treeName, child);\n\n  const previewInfo: PreviewInfo = {\n    pid,\n    port,\n    mode,\n    startedAt: new Date().toISOString(),\n  };\n\n  // Save to config\n  await updateConfig((c) => ({\n    ...c,\n    previews: {\n      ...c.previews,\n      [treeName]: previewInfo,\n    },\n  }), cwd);\n\n  return previewInfo;\n}\n\nexport async function stopPreview(\n  treeName: string,\n  cwd: string = process.cwd()\n): Promise<void> {\n  const config = await readConfig(cwd);\n  const preview = config.previews[treeName];\n\n  if (!preview) {\n    throw new Error(`No preview running for '${treeName}'`);\n  }\n\n  // Kill the process tree\n  await new Promise<void>((resolve, reject) => {\n    treeKill(preview.pid, 'SIGTERM', (err) => {\n      if (err) {\n        // Process might already be dead\n        resolve();\n      } else {\n        resolve();\n      }\n    });\n  });\n\n  await cleanupPreview(treeName, cwd);\n}\n\nexport async function stopAllPreviews(cwd: string = process.cwd()): Promise<void> {\n  const config = await readConfig(cwd);\n\n  for (const treeName of Object.keys(config.previews)) {\n    try {\n      await stopPreview(treeName, cwd);\n    } catch {\n      // Continue stopping others\n    }\n  }\n}\n\nasync function cleanupPreview(\n  treeName: string,\n  cwd: string = process.cwd()\n): Promise<void> {\n  runningProcesses.delete(treeName);\n\n  await updateConfig((c) => {\n    const { [treeName]: _, ...remainingPreviews } = c.previews;\n    return {\n      ...c,\n      previews: remainingPreviews,\n    };\n  }, cwd);\n}\n\nexport async function getRunningPreviews(\n  cwd: string = process.cwd()\n): Promise<Record<string, PreviewInfo>> {\n  const config = await readConfig(cwd);\n  return config.previews;\n}\n\nexport async function isPreviewRunning(\n  treeName: string,\n  cwd: string = process.cwd()\n): Promise<boolean> {\n  const config = await readConfig(cwd);\n  const preview = config.previews[treeName];\n\n  if (!preview) {\n    return false;\n  }\n\n  // Check if process is actually running\n  try {\n    process.kill(preview.pid, 0);\n    return true;\n  } catch {\n    // Process not running - clean up stale entry\n    await cleanupPreview(treeName, cwd);\n    return false;\n  }\n}\n","import chalk from 'chalk';\nimport ora from 'ora';\nimport { readConfig, updateConfig } from '../lib/config.js';\nimport { createCurrentLink, getCurrentTreeName } from '../lib/symlink.js';\n\nexport async function tend(name: string): Promise<void> {\n  const cwd = process.cwd();\n  const spinner = ora(`Switching to '${name}'...`).start();\n\n  try {\n    const config = await readConfig(cwd);\n\n    // Check if tree exists\n    if (!config.trees[name]) {\n      spinner.fail(`Tree '${name}' not found`);\n      console.log('');\n      console.log(chalk.gray('Available trees:'));\n      for (const treeName of Object.keys(config.trees)) {\n        console.log(chalk.gray(`  - ${treeName}`));\n      }\n      process.exit(1);\n    }\n\n    const currentTree = await getCurrentTreeName(cwd);\n    if (currentTree === name) {\n      spinner.info(`Already on '${name}'`);\n      return;\n    }\n\n    // Update symlink\n    await createCurrentLink(name, cwd);\n\n    // Update config\n    await updateConfig((c) => ({\n      ...c,\n      current: name,\n    }), cwd);\n\n    const tree = config.trees[name];\n    spinner.succeed(`Now tending '${name}'`);\n\n    console.log('');\n    console.log(chalk.gray(`  Branch: ${tree.branch}`));\n    console.log(chalk.gray(`  Path:   ${tree.path}`));\n    console.log('');\n    console.log(chalk.cyan('The `current` symlink now points to this tree.'));\n  } catch (error) {\n    spinner.fail('Failed to switch tree');\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    process.exit(1);\n  }\n}\n","import chalk from 'chalk';\nimport ora from 'ora';\nimport path from 'path';\nimport fs from 'fs-extra';\nimport { readConfig, updateConfig, getTreesDir } from '../lib/config.js';\nimport { removeWorktree } from '../lib/git.js';\nimport { getCurrentTreeName, removeCurrentLink } from '../lib/symlink.js';\nimport { isPreviewRunning, stopPreview } from '../lib/preview.js';\n\ninterface UprootOptions {\n  force?: boolean;\n}\n\nexport async function uproot(name: string, options: UprootOptions): Promise<void> {\n  const cwd = process.cwd();\n  const spinner = ora(`Uprooting '${name}'...`).start();\n\n  try {\n    const config = await readConfig(cwd);\n\n    // Check if tree exists\n    if (!config.trees[name]) {\n      spinner.fail(`Tree '${name}' not found`);\n      process.exit(1);\n    }\n\n    const tree = config.trees[name];\n\n    // Check if this is the main repo (not a real worktree)\n    // The main tree points to the repo root, not .grove/trees/*\n    const treesDir = getTreesDir(cwd);\n    const isRealWorktree = tree.path.startsWith(treesDir);\n\n    if (!isRealWorktree) {\n      spinner.fail(`Cannot uproot '${name}' - it's the main repository`);\n      console.log(chalk.gray('The main tree represents your original repository.'));\n      console.log(chalk.gray('You can only uproot worktrees created with `grove plant`.'));\n      process.exit(1);\n    }\n\n    // Check if it's the current tree\n    const currentTree = await getCurrentTreeName(cwd);\n    const isCurrent = currentTree === name;\n\n    if (isCurrent && Object.keys(config.trees).length === 1) {\n      spinner.fail('Cannot uproot the last tree in the grove');\n      console.log(chalk.gray('At least one tree must remain.'));\n      process.exit(1);\n    }\n\n    // Stop preview if running\n    if (await isPreviewRunning(name, cwd)) {\n      spinner.text = 'Stopping preview server...';\n      await stopPreview(name, cwd);\n    }\n\n    // Remove git worktree\n    spinner.text = 'Removing worktree...';\n    await removeWorktree(tree.path, { force: options.force }, config.repo);\n\n    // Update config\n    await updateConfig((c) => {\n      const { [name]: _, ...remainingTrees } = c.trees;\n      return {\n        ...c,\n        trees: remainingTrees,\n        current: c.current === name ? null : c.current,\n      };\n    }, cwd);\n\n    // If this was the current tree, update symlink to another tree\n    if (isCurrent) {\n      const remainingTrees = Object.keys(config.trees).filter((t) => t !== name);\n      if (remainingTrees.length > 0) {\n        const newCurrent = remainingTrees[0];\n        const newTreePath = config.trees[newCurrent].path;\n\n        // Update the symlink to point to the new tree's actual path\n        const currentLinkPath = path.join(cwd, 'current');\n        // Use lstat to check for symlink (pathExists follows symlinks)\n        try {\n          await fs.lstat(currentLinkPath);\n          await fs.unlink(currentLinkPath);\n        } catch {\n          // Symlink doesn't exist, that's fine\n        }\n        // If the new tree is the main repo (same as cwd), use '.' as the symlink target\n        const relativePath = path.relative(cwd, newTreePath) || '.';\n        await fs.symlink(relativePath, currentLinkPath);\n\n        await updateConfig((c) => ({\n          ...c,\n          current: newCurrent,\n        }), cwd);\n        spinner.succeed(`Uprooted '${name}', switched to '${newCurrent}'`);\n      } else {\n        await removeCurrentLink(cwd);\n        spinner.succeed(`Uprooted '${name}'`);\n      }\n    } else {\n      spinner.succeed(`Uprooted '${name}'`);\n    }\n\n    console.log('');\n    console.log(chalk.gray(`  Branch: ${tree.branch}`));\n    console.log(chalk.gray(`  Path:   ${tree.path} (removed)`));\n  } catch (error) {\n    spinner.fail('Failed to uproot tree');\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n\n    if (!options.force) {\n      console.log('');\n      console.log(chalk.yellow('Tip: Use --force to force removal'));\n    }\n    process.exit(1);\n  }\n}\n","import chalk from 'chalk';\nimport ora from 'ora';\nimport { readConfig } from '../lib/config.js';\nimport {\n  startPreview as startPreviewServer,\n  stopPreview as stopPreviewServer,\n  stopAllPreviews,\n  isPreviewRunning,\n} from '../lib/preview.js';\n\ninterface PreviewOptions {\n  dev?: boolean;\n  build?: boolean;\n  port?: number;\n}\n\nexport async function preview(\n  action: string,\n  name: string | undefined,\n  options: PreviewOptions\n): Promise<void> {\n  const cwd = process.cwd();\n\n  // Handle 'stop' action\n  if (action === 'stop') {\n    if (name) {\n      await stopTree(name, cwd);\n    } else {\n      await stopAll(cwd);\n    }\n    return;\n  }\n\n  // Otherwise, action is the tree name to preview\n  const treeName = action;\n  await startTree(treeName, options, cwd);\n}\n\nasync function startTree(\n  name: string,\n  options: PreviewOptions,\n  cwd: string\n): Promise<void> {\n  const spinner = ora(`Starting preview for '${name}'...`).start();\n\n  try {\n    const config = await readConfig(cwd);\n\n    if (!config.trees[name]) {\n      spinner.fail(`Tree '${name}' not found`);\n      process.exit(1);\n    }\n\n    // Check if already running\n    if (await isPreviewRunning(name, cwd)) {\n      const preview = config.previews[name];\n      spinner.info(`Preview for '${name}' is already running on port ${preview.port}`);\n      console.log('');\n      console.log(chalk.cyan(`  http://localhost:${preview.port}`));\n      return;\n    }\n\n    const mode = options.build ? 'build' : 'dev';\n    spinner.text = mode === 'build' ? 'Building and starting server...' : 'Starting dev server...';\n\n    const previewInfo = await startPreviewServer(name, mode, cwd);\n\n    spinner.succeed(`Preview started for '${name}'`);\n\n    console.log('');\n    console.log(chalk.green('Server running:'));\n    console.log(chalk.cyan(`  http://localhost:${previewInfo.port}`));\n    console.log('');\n    console.log(chalk.gray(`Mode: ${mode}`));\n    console.log(chalk.gray(`PID: ${previewInfo.pid}`));\n    console.log('');\n    console.log(chalk.yellow('Press Ctrl+C to stop the server'));\n  } catch (error) {\n    spinner.fail('Failed to start preview');\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    process.exit(1);\n  }\n}\n\nasync function stopTree(name: string, cwd: string): Promise<void> {\n  const spinner = ora(`Stopping preview for '${name}'...`).start();\n\n  try {\n    if (!(await isPreviewRunning(name, cwd))) {\n      spinner.info(`No preview running for '${name}'`);\n      return;\n    }\n\n    await stopPreviewServer(name, cwd);\n    spinner.succeed(`Stopped preview for '${name}'`);\n  } catch (error) {\n    spinner.fail('Failed to stop preview');\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    process.exit(1);\n  }\n}\n\nasync function stopAll(cwd: string): Promise<void> {\n  const spinner = ora('Stopping all previews...').start();\n\n  try {\n    const config = await readConfig(cwd);\n    const runningCount = Object.keys(config.previews).length;\n\n    if (runningCount === 0) {\n      spinner.info('No previews running');\n      return;\n    }\n\n    await stopAllPreviews(cwd);\n    spinner.succeed(`Stopped ${runningCount} preview(s)`);\n  } catch (error) {\n    spinner.fail('Failed to stop previews');\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    process.exit(1);\n  }\n}\n","import chalk from 'chalk';\nimport { readConfig } from '../lib/config.js';\nimport { getCurrentTreeName } from '../lib/symlink.js';\nimport { getRunningPreviews, isPreviewRunning } from '../lib/preview.js';\n\nexport async function status(): Promise<void> {\n  const cwd = process.cwd();\n\n  try {\n    const config = await readConfig(cwd);\n    const currentTree = await getCurrentTreeName(cwd);\n    const previews = await getRunningPreviews(cwd);\n\n    console.log(chalk.bold('\\nGrove Status\\n'));\n\n    // Current tree\n    console.log(chalk.white('Current Tree:'));\n    if (currentTree && config.trees[currentTree]) {\n      const tree = config.trees[currentTree];\n      console.log(chalk.green(`  ${currentTree}`));\n      console.log(chalk.gray(`  Branch: ${tree.branch}`));\n      console.log(chalk.gray(`  Path: ./current`));\n    } else {\n      console.log(chalk.yellow('  None selected'));\n    }\n    console.log('');\n\n    // Running previews\n    console.log(chalk.white('Running Previews:'));\n    const previewEntries = Object.entries(previews);\n\n    if (previewEntries.length === 0) {\n      console.log(chalk.gray('  No previews running'));\n    } else {\n      for (const [name, preview] of previewEntries) {\n        const running = await isPreviewRunning(name, cwd);\n        if (running) {\n          console.log(\n            chalk.cyan(`  ${name}`) +\n            chalk.gray(` â†’ http://localhost:${preview.port}`) +\n            chalk.gray(` (${preview.mode})`)\n          );\n        }\n      }\n    }\n    console.log('');\n\n    // Summary\n    const treeCount = Object.keys(config.trees).length;\n    const runningCount = previewEntries.filter(\n      async ([name]) => await isPreviewRunning(name, cwd)\n    ).length;\n\n    console.log(chalk.white('Summary:'));\n    console.log(chalk.gray(`  Trees: ${treeCount}`));\n    console.log(chalk.gray(`  Previews running: ${runningCount}`));\n    console.log(chalk.gray(`  Package manager: ${config.packageManager}`));\n    console.log(chalk.gray(`  Framework: ${config.framework}`));\n    console.log('');\n  } catch (error) {\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    process.exit(1);\n  }\n}\n","import chalk from 'chalk';\nimport ora from 'ora';\nimport { readConfig, getTreePath } from '../lib/config.js';\nimport {\n  Editor,\n  openInEditor,\n  detectAvailableEditors,\n  getEditorName,\n  getSupportedEditors,\n} from '../lib/editor.js';\n\ninterface OpenOptions {\n  editor?: string;\n}\n\nexport async function open(name: string, options: OpenOptions): Promise<void> {\n  const cwd = process.cwd();\n\n  try {\n    const config = await readConfig(cwd);\n\n    // Validate tree exists\n    if (!config.trees[name]) {\n      console.log(chalk.red(`Tree '${name}' not found`));\n      console.log('');\n      console.log(chalk.gray('Available trees:'));\n      for (const treeName of Object.keys(config.trees)) {\n        console.log(chalk.gray(`  - ${treeName}`));\n      }\n      process.exit(1);\n    }\n\n    // Determine which editor to use\n    let editor: Editor;\n\n    if (options.editor) {\n      const supported = getSupportedEditors();\n      if (!supported.includes(options.editor as Editor)) {\n        console.log(chalk.red(`Unknown editor: ${options.editor}`));\n        console.log(chalk.gray(`Supported: ${supported.join(', ')}`));\n        process.exit(1);\n      }\n      editor = options.editor as Editor;\n    } else {\n      // Auto-detect available editor (prefer cursor for AI workflows)\n      const available = await detectAvailableEditors();\n\n      if (available.length === 0) {\n        console.log(chalk.red('No supported editors found'));\n        console.log(chalk.gray('Install one of: cursor, code (VS Code), claude, zed'));\n        process.exit(1);\n      }\n\n      // Preference order for AI coding\n      const preferenceOrder: Editor[] = ['cursor', 'claude', 'code', 'zed'];\n      editor = preferenceOrder.find((e) => available.includes(e)) || available[0];\n    }\n\n    const spinner = ora(`Opening '${name}' in ${getEditorName(editor)}...`).start();\n\n    await openInEditor(name, editor, cwd);\n\n    const treePath = getTreePath(name, cwd);\n    spinner.succeed(`Opened '${name}' in ${getEditorName(editor)}`);\n\n    console.log('');\n    console.log(chalk.gray(`  Path: ${treePath}`));\n    console.log(chalk.gray(`  Branch: ${config.trees[name].branch}`));\n  } catch (error) {\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    process.exit(1);\n  }\n}\n","import chalk from 'chalk';\nimport { readConfig, getTreePath } from '../lib/config.js';\nimport { spawnClaudeCode } from '../lib/editor.js';\n\nexport async function spawn(name: string): Promise<void> {\n  const cwd = process.cwd();\n\n  try {\n    const config = await readConfig(cwd);\n\n    // Validate tree exists\n    if (!config.trees[name]) {\n      console.log(chalk.red(`Tree '${name}' not found`));\n      console.log('');\n      console.log(chalk.gray('Available trees:'));\n      for (const treeName of Object.keys(config.trees)) {\n        console.log(chalk.gray(`  - ${treeName}`));\n      }\n      process.exit(1);\n    }\n\n    const treePath = getTreePath(name, cwd);\n    const tree = config.trees[name];\n\n    console.log(chalk.cyan(`Spawning Claude Code in '${name}'...`));\n    console.log(chalk.gray(`  Path: ${treePath}`));\n    console.log(chalk.gray(`  Branch: ${tree.branch}`));\n    console.log('');\n\n    // This will block until Claude Code exits\n    await spawnClaudeCode(name, cwd);\n\n    console.log('');\n    console.log(chalk.gray('Claude Code session ended.'));\n  } catch (error) {\n    console.error(chalk.red(error instanceof Error ? error.message : String(error)));\n    process.exit(1);\n  }\n}\n","import { readConfig, getTreePath } from '../lib/config.js';\n\nexport async function getPath(name: string): Promise<void> {\n  const cwd = process.cwd();\n\n  try {\n    const config = await readConfig(cwd);\n\n    // Validate tree exists\n    if (!config.trees[name]) {\n      console.error(`Tree '${name}' not found`);\n      process.exit(1);\n    }\n\n    const treePath = getTreePath(name, cwd);\n\n    // Output just the path - useful for shell integration\n    // e.g., cd $(grove path feature-x)\n    console.log(treePath);\n  } catch (error) {\n    console.error(error instanceof Error ? error.message : String(error));\n    process.exit(1);\n  }\n}\n"],"mappings":";;;AACA,SAAS,eAAe;;;ACDxB,OAAOA,SAAQ;AACf,OAAOC,WAAU;AACjB,OAAO,WAAW;AAClB,OAAO,SAAS;;;ACHhB,OAAO,QAAQ;AACf,OAAO,UAAU;;;ACgCV,IAAM,YAAY;AAClB,IAAM,eAAe;AACrB,IAAM,cAAc;AACpB,IAAM,eAAe;AACrB,IAAM,eAAe;;;AD3BrB,SAAS,YAAY,MAAc,QAAQ,IAAI,GAAW;AAC/D,SAAO,KAAK,KAAK,KAAK,SAAS;AACjC;AAEO,SAAS,cAAc,MAAc,QAAQ,IAAI,GAAW;AACjE,SAAO,KAAK,KAAK,YAAY,GAAG,GAAG,YAAY;AACjD;AAEO,SAAS,YAAY,MAAc,QAAQ,IAAI,GAAW;AAC/D,SAAO,KAAK,KAAK,YAAY,GAAG,GAAG,WAAW;AAChD;AAEO,SAAS,aAAa,MAAc,QAAQ,IAAI,GAAW;AAChE,SAAO,KAAK,KAAK,YAAY,GAAG,GAAG,YAAY;AACjD;AAEO,SAAS,YAAY,MAAc,MAAc,QAAQ,IAAI,GAAW;AAC7E,SAAO,KAAK,KAAK,YAAY,GAAG,GAAG,IAAI;AACzC;AAEA,eAAsB,YAAY,MAAc,QAAQ,IAAI,GAAqB;AAC/E,SAAO,GAAG,WAAW,cAAc,GAAG,CAAC;AACzC;AAEA,eAAsB,WAAW,MAAc,QAAQ,IAAI,GAAyB;AAClF,QAAM,aAAa,cAAc,GAAG;AACpC,MAAI,CAAE,MAAM,GAAG,WAAW,UAAU,GAAI;AACtC,UAAM,IAAI,MAAM,gDAAgD;AAAA,EAClE;AACA,SAAO,GAAG,SAAS,UAAU;AAC/B;AAEA,eAAsB,YACpB,QACA,MAAc,QAAQ,IAAI,GACX;AACf,QAAM,aAAa,cAAc,GAAG;AACpC,QAAM,GAAG,UAAU,YAAY,QAAQ,EAAE,QAAQ,EAAE,CAAC;AACtD;AAEA,eAAsB,aACpB,SACA,MAAc,QAAQ,IAAI,GACJ;AACtB,QAAM,SAAS,MAAM,WAAW,GAAG;AACnC,QAAM,UAAU,MAAM,QAAQ,MAAM;AACpC,QAAM,YAAY,SAAS,GAAG;AAC9B,SAAO;AACT;AAEO,SAAS,oBAAoB,MAA2B;AAC7D,SAAO;AAAA,IACL,SAAS;AAAA,IACT;AAAA,IACA,gBAAgB;AAAA,IAChB,WAAW;AAAA,IACX,OAAO,CAAC;AAAA,IACR,SAAS;AAAA,IACT,UAAU,CAAC;AAAA,EACb;AACF;;;AEtEA,SAAS,aAAa;AAStB,eAAsB,UAAU,MAAc,QAAQ,IAAI,GAAqB;AAC7E,MAAI;AACF,UAAM,MAAM,OAAO,CAAC,aAAa,WAAW,GAAG,EAAE,IAAI,CAAC;AACtD,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEA,eAAsB,YAAY,MAAc,QAAQ,IAAI,GAAoB;AAC9E,QAAM,EAAE,OAAO,IAAI,MAAM,MAAM,OAAO,CAAC,aAAa,iBAAiB,GAAG,EAAE,IAAI,CAAC;AAC/E,SAAO,OAAO,KAAK;AACrB;AAEA,eAAsB,iBAAiB,MAAc,QAAQ,IAAI,GAAoB;AACnF,QAAM,EAAE,OAAO,IAAI,MAAM,MAAM,OAAO,CAAC,aAAa,gBAAgB,MAAM,GAAG,EAAE,IAAI,CAAC;AACpF,SAAO,OAAO,KAAK;AACrB;AAEA,eAAsB,aAAa,QAAgB,MAAc,QAAQ,IAAI,GAAqB;AAChG,MAAI;AACF,UAAM,MAAM,OAAO,CAAC,aAAa,YAAY,MAAM,GAAG,EAAE,IAAI,CAAC;AAC7D,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEA,eAAsB,mBAAmB,QAAgB,MAAc,QAAQ,IAAI,GAAqB;AACtG,MAAI;AACF,UAAM,MAAM,OAAO,CAAC,aAAa,YAAY,UAAU,MAAM,EAAE,GAAG,EAAE,IAAI,CAAC;AACzE,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEA,eAAsB,eACpB,YACA,QACA,UAA2D,CAAC,GAC5D,MAAc,QAAQ,IAAI,GACX;AACf,QAAM,OAAO,CAAC,YAAY,KAAK;AAE/B,MAAI,QAAQ,cAAc;AACxB,SAAK,KAAK,MAAM,MAAM;AACtB,SAAK,KAAK,UAAU;AACpB,QAAI,QAAQ,YAAY;AACtB,WAAK,KAAK,QAAQ,UAAU;AAAA,IAC9B;AAAA,EACF,OAAO;AACL,SAAK,KAAK,YAAY,MAAM;AAAA,EAC9B;AAEA,QAAM,MAAM,OAAO,MAAM,EAAE,IAAI,CAAC;AAClC;AAEA,eAAsB,eACpB,YACA,UAA+B,CAAC,GAChC,MAAc,QAAQ,IAAI,GACX;AACf,QAAM,OAAO,CAAC,YAAY,QAAQ;AAClC,MAAI,QAAQ,OAAO;AACjB,SAAK,KAAK,SAAS;AAAA,EACrB;AACA,OAAK,KAAK,UAAU;AAEpB,QAAM,MAAM,OAAO,MAAM,EAAE,IAAI,CAAC;AAClC;AAgCA,eAAsB,YAAY,QAAgB,MAAc,QAAQ,IAAI,GAAkB;AAC5F,QAAM,MAAM,OAAO,CAAC,SAAS,UAAU,MAAM,GAAG,EAAE,IAAI,CAAC;AACzD;;;ACjHA,OAAOC,SAAQ;AACf,OAAOC,WAAU;AACjB,SAAS,SAAAC,cAAa;AACtB,OAAO,YAAY;AAUnB,IAAM,YAA4C;AAAA,EAChD,kBAAkB;AAAA,EAClB,aAAa;AAAA,EACb,qBAAqB;AACvB;AAEA,eAAsB,qBACpB,MAAc,QAAQ,IAAI,GACD;AAEzB,aAAW,CAAC,UAAU,OAAO,KAAK,OAAO,QAAQ,SAAS,GAAG;AAC3D,QAAI,MAAMC,IAAG,WAAWC,MAAK,KAAK,KAAK,QAAQ,CAAC,GAAG;AACjD,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAEA,eAAsB,gBACpB,MAAc,QAAQ,IAAI,GACI;AAC9B,aAAW,CAAC,UAAU,OAAO,KAAK,OAAO,QAAQ,SAAS,GAAG;AAC3D,UAAM,eAAeA,MAAK,KAAK,KAAK,QAAQ;AAC5C,QAAI,MAAMD,IAAG,WAAW,YAAY,GAAG;AACrC,YAAM,UAAU,MAAMA,IAAG,SAAS,YAAY;AAC9C,YAAM,OAAO,OAAO,WAAW,QAAQ,EAAE,OAAO,OAAO,EAAE,OAAO,KAAK;AACrE,aAAO,EAAE,MAAM,SAAS,MAAM,cAAc,KAAK;AAAA,IACnD;AAAA,EACF;AACA,SAAO;AACT;AAEA,eAAsB,oBACpB,SACA,WACA,UAA2D,CAAC,GAC7C;AACf,QAAM,OAAiB,CAAC,SAAS;AAEjC,MAAI,YAAY,UAAU,QAAQ,kBAAkB,QAAQ,UAAU;AACpE,UAAM,YAAYC,MAAK,KAAK,aAAa,QAAQ,QAAQ,GAAG,YAAY;AACxE,UAAMD,IAAG,UAAU,SAAS;AAC5B,SAAK,KAAK,eAAe,SAAS;AAAA,EACpC;AAGA,MAAI,YAAY,OAAO;AACrB,SAAK,KAAK,kBAAkB;AAAA,EAC9B,WAAW,YAAY,QAAQ;AAC7B,SAAK,KAAK,kBAAkB;AAAA,EAC9B,WAAW,YAAY,QAAQ;AAC7B,SAAK,KAAK,kBAAkB;AAAA,EAC9B;AAEA,QAAME,OAAM,SAAS,MAAM;AAAA,IACzB,KAAK;AAAA,IACL,OAAO;AAAA,EACT,CAAC;AACH;AAEA,eAAsB,sBACpB,WACA,WACkB;AAClB,QAAM,iBAAiB,MAAM,gBAAgB,SAAS;AACtD,QAAM,iBAAiB,MAAM,gBAAgB,SAAS;AAEtD,MAAI,CAAC,kBAAkB,CAAC,gBAAgB;AACtC,WAAO;AAAA,EACT;AAGA,SACE,eAAe,SAAS,eAAe,QACvC,eAAe,SAAS,eAAe;AAE3C;AAEA,eAAsB,mBACpB,WACA,WACe;AACf,QAAM,gBAAgBD,MAAK,KAAK,WAAW,cAAc;AACzD,QAAM,gBAAgBA,MAAK,KAAK,WAAW,cAAc;AAEzD,MAAI,CAAE,MAAMD,IAAG,WAAW,aAAa,GAAI;AACzC,UAAM,IAAI,MAAM,kCAAkC,aAAa,EAAE;AAAA,EACnE;AAGA,MAAI,MAAMA,IAAG,WAAW,aAAa,GAAG;AACtC,UAAMA,IAAG,OAAO,aAAa;AAAA,EAC/B;AAGA,QAAM,eAAeC,MAAK,SAAS,WAAW,aAAa;AAC3D,QAAMD,IAAG,QAAQ,cAAc,aAAa;AAC9C;AAqBA,eAAsB,eAAe,KAA+B;AAClE,SAAOG,IAAG,WAAWC,MAAK,KAAK,KAAK,cAAc,CAAC;AACrD;;;ACrIA,OAAOC,SAAQ;AACf,OAAOC,WAAU;AAWV,IAAM,oBAAwD;AAAA,EACnE,QAAQ;AAAA,IACN,YAAY;AAAA,IACZ,cAAc;AAAA,IACd,cAAc;AAAA,IACd,aAAa;AAAA,IACb,UAAU;AAAA,EACZ;AAAA,EACA,MAAM;AAAA,IACJ,YAAY;AAAA,IACZ,cAAc;AAAA,IACd,cAAc;AAAA,IACd,aAAa;AAAA,IACb,UAAU;AAAA,EACZ;AAAA,EACA,KAAK;AAAA,IACH,YAAY;AAAA,IACZ,cAAc;AAAA,IACd,cAAc;AAAA,IACd,aAAa;AAAA,IACb,UAAU;AAAA,EACZ;AAAA,EACA,SAAS;AAAA,IACP,YAAY;AAAA,IACZ,cAAc;AAAA,IACd,cAAc;AAAA,IACd,aAAa;AAAA,IACb,UAAU;AAAA,EACZ;AACF;AAEA,eAAsB,gBAAgB,MAAc,QAAQ,IAAI,GAAuB;AACrF,QAAM,kBAAkBA,MAAK,KAAK,KAAK,cAAc;AAErD,MAAI,CAAE,MAAMD,IAAG,WAAW,eAAe,GAAI;AAC3C,WAAO;AAAA,EACT;AAEA,MAAI;AACF,UAAM,MAAM,MAAMA,IAAG,SAAS,eAAe;AAC7C,UAAM,OAAO;AAAA,MACX,GAAG,IAAI;AAAA,MACP,GAAG,IAAI;AAAA,IACT;AAGA,QAAI,KAAK,MAAM;AACb,aAAO;AAAA,IACT;AAGA,QAAI,KAAK,MAAM;AACb,aAAO;AAAA,IACT;AAGA,QAAI,KAAK,eAAe,GAAG;AACzB,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAMA,eAAsB,cAAc,MAAc,QAAQ,IAAI,GAAoB;AAChF,QAAM,kBAAkBE,MAAK,KAAK,KAAK,cAAc;AAErD,MAAI,MAAMC,IAAG,WAAW,eAAe,GAAG;AACxC,QAAI;AACF,YAAM,MAAM,MAAMA,IAAG,SAAS,eAAe;AAC7C,UAAI,IAAI,SAAS,KAAK;AACpB,eAAO;AAAA,MACT;AACA,UAAI,IAAI,SAAS,OAAO;AACtB,eAAO;AAAA,MACT;AAAA,IACF,QAAQ;AAAA,IAER;AAAA,EACF;AAEA,QAAM,YAAY,MAAM,gBAAgB,GAAG;AAC3C,SAAO,kBAAkB,SAAS,EAAE;AACtC;AAEA,eAAsB,gBAAgB,MAAc,QAAQ,IAAI,GAAoB;AAClF,QAAM,kBAAkBD,MAAK,KAAK,KAAK,cAAc;AAErD,MAAI,MAAMC,IAAG,WAAW,eAAe,GAAG;AACxC,QAAI;AACF,YAAM,MAAM,MAAMA,IAAG,SAAS,eAAe;AAC7C,UAAI,IAAI,SAAS,OAAO;AACtB,eAAO;AAAA,MACT;AAAA,IACF,QAAQ;AAAA,IAER;AAAA,EACF;AAEA,QAAM,YAAY,MAAM,gBAAgB,GAAG;AAC3C,SAAO,kBAAkB,SAAS,EAAE;AACtC;AAEA,eAAsB,gBAAgB,MAAc,QAAQ,IAAI,GAAoB;AAClF,QAAM,kBAAkBD,MAAK,KAAK,KAAK,cAAc;AAErD,MAAI,MAAMC,IAAG,WAAW,eAAe,GAAG;AACxC,QAAI;AACF,YAAM,MAAM,MAAMA,IAAG,SAAS,eAAe;AAC7C,UAAI,IAAI,SAAS,OAAO;AACtB,eAAO;AAAA,MACT;AACA,UAAI,IAAI,SAAS,OAAO;AACtB,eAAO;AAAA,MACT;AAAA,IACF,QAAQ;AAAA,IAER;AAAA,EACF;AAEA,QAAM,YAAY,MAAM,gBAAgB,GAAG;AAC3C,SAAO,kBAAkB,SAAS,EAAE;AACtC;;;AL1HA,eAAsB,OAAsB;AAC1C,QAAM,MAAM,QAAQ,IAAI;AAGxB,MAAI,MAAM,YAAY,GAAG,GAAG;AAC1B,YAAQ,IAAI,MAAM,OAAO,iDAAiD,CAAC;AAC3E;AAAA,EACF;AAGA,MAAI,CAAE,MAAM,UAAU,GAAG,GAAI;AAC3B,YAAQ,IAAI,MAAM,IAAI,8BAA8B,CAAC;AACrD,YAAQ,IAAI,MAAM,KAAK,gDAAgD,CAAC;AACxE,YAAQ,KAAK,CAAC;AAAA,EAChB;AAEA,QAAM,UAAU,IAAI,uBAAuB,EAAE,MAAM;AAEnD,MAAI;AACF,UAAM,WAAW,MAAM,YAAY,GAAG;AACtC,UAAM,gBAAgB,MAAM,iBAAiB,GAAG;AAGhD,UAAM,WAAW,YAAY,GAAG;AAChC,UAAM,WAAW,YAAY,GAAG;AAChC,UAAM,YAAY,aAAa,GAAG;AAElC,UAAMC,IAAG,UAAU,QAAQ;AAC3B,UAAMA,IAAG,UAAU,QAAQ;AAC3B,UAAMA,IAAG,UAAU,SAAS;AAG5B,YAAQ,OAAO;AACf,UAAM,iBAAiB,MAAM,qBAAqB,GAAG;AACrD,UAAM,YAAY,MAAM,gBAAgB,GAAG;AAG3C,UAAM,SAAS,oBAAoB,QAAQ;AAC3C,WAAO,iBAAiB;AACxB,WAAO,YAAY;AAKnB,UAAM,eAAe;AACrB,WAAO,MAAM,YAAY,IAAI;AAAA,MAC3B,QAAQ;AAAA,MACR,MAAM;AAAA;AAAA,MACN,UAAS,oBAAI,KAAK,GAAE,YAAY;AAAA,IAClC;AACA,WAAO,UAAU;AAGjB,UAAM,YAAY,QAAQ,GAAG;AAI7B,UAAM,kBAAkBC,MAAK,KAAK,KAAK,SAAS;AAChD,QAAI,MAAMD,IAAG,WAAW,eAAe,GAAG;AACxC,YAAMA,IAAG,OAAO,eAAe;AAAA,IACjC;AACA,UAAMA,IAAG,QAAQ,KAAK,eAAe;AAGrC,UAAM,gBAAgBC,MAAK,KAAK,KAAK,YAAY;AACjD,QAAI,MAAMD,IAAG,WAAW,aAAa,GAAG;AACtC,YAAM,YAAY,MAAMA,IAAG,SAAS,eAAe,OAAO;AAC1D,UAAI,CAAC,UAAU,SAAS,SAAS,GAAG;AAClC,cAAMA,IAAG,WAAW,eAAe;AAAA;AAAA,EAA+B,SAAS;AAAA;AAAA,CAAc;AAAA,MAC3F;AAAA,IACF,OAAO;AACL,YAAMA,IAAG,UAAU,eAAe;AAAA,EAA6B,SAAS;AAAA;AAAA,CAAc;AAAA,IACxF;AAEA,YAAQ,QAAQ,oBAAoB;AAEpC,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAI,MAAM,MAAM,UAAU,CAAC;AACnC,YAAQ,IAAI,MAAM,KAAK,KAAK,SAAS,wCAAwC,CAAC;AAC9E,YAAQ,IAAI,MAAM,KAAK,KAAK,SAAS,iCAAiC,CAAC;AACvE,YAAQ,IAAI,MAAM,KAAK,+CAA+C,CAAC;AACvE,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAI,MAAM,KAAK,WAAW,CAAC;AACnC,YAAQ,IAAI,MAAM,KAAK,sBAAsB,cAAc,EAAE,CAAC;AAC9D,YAAQ,IAAI,MAAM,KAAK,gBAAgB,SAAS,EAAE,CAAC;AACnD,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAI,MAAM,KAAK,aAAa,CAAC;AACrC,YAAQ,IAAI,MAAM,KAAK,kDAAkD,CAAC;AAC1E,YAAQ,IAAI,MAAM,KAAK,2CAA2C,CAAC;AACnE,YAAQ,IAAI,MAAM,KAAK,6CAA6C,CAAC;AAAA,EACvE,SAAS,OAAO;AACd,YAAQ,KAAK,4BAA4B;AACzC,YAAQ,MAAM,MAAM,IAAI,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,CAAC;AAC/E,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;;;AMhHA,OAAOE,YAAW;AAClB,OAAOC,UAAS;;;ACFhB,OAAOC,SAAQ;AACf,OAAOC,WAAU;AAIV,SAAS,mBAAmB,MAAc,QAAQ,IAAI,GAAW;AACtE,SAAOC,MAAK,KAAK,KAAK,YAAY;AACpC;AAEA,eAAsB,kBACpB,UACA,MAAc,QAAQ,IAAI,GACX;AACf,QAAM,WAAW,mBAAmB,GAAG;AACvC,QAAM,aAAa,YAAY,UAAU,GAAG;AAG5C,MAAI,MAAMC,IAAG,WAAW,QAAQ,GAAG;AACjC,UAAMA,IAAG,OAAO,QAAQ;AAAA,EAC1B;AAGA,QAAM,eAAeD,MAAK,SAAS,KAAK,UAAU;AAClD,QAAMC,IAAG,QAAQ,cAAc,QAAQ;AACzC;AAEA,eAAsB,kBAAkB,MAAc,QAAQ,IAAI,GAAkB;AAClF,QAAM,WAAW,mBAAmB,GAAG;AACvC,MAAI,MAAMA,IAAG,WAAW,QAAQ,GAAG;AACjC,UAAMA,IAAG,OAAO,QAAQ;AAAA,EAC1B;AACF;AAEA,eAAsB,mBAAmB,MAAc,QAAQ,IAAI,GAA2B;AAC5F,QAAM,WAAW,mBAAmB,GAAG;AAEvC,MAAI;AACF,UAAM,SAAS,MAAMA,IAAG,SAAS,QAAQ;AAGzC,QAAI,WAAW,KAAK;AAElB,YAAM,SAAS,MAAM,WAAW,GAAG;AACnC,iBAAW,CAAC,MAAM,IAAI,KAAK,OAAO,QAAQ,OAAO,KAAK,GAAG;AAEvD,cAAM,qBAAqBD,MAAK,QAAQ,KAAK,IAAI;AACjD,cAAM,gBAAgBA,MAAK,QAAQ,GAAG;AACtC,YAAI,uBAAuB,eAAe;AACxC,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAGA,UAAM,QAAQ,OAAO,MAAMA,MAAK,GAAG;AACnC,WAAO,MAAM,MAAM,SAAS,CAAC;AAAA,EAC/B,QAAQ;AACN,WAAO;AAAA,EACT;AACF;;;AC5DA,SAAS,SAAAE,cAAa;AACtB,OAAOC,SAAQ;AACf,OAAOC,WAAU;AAWjB,IAAM,UAAwC;AAAA,EAC5C,QAAQ;AAAA,IACN,SAAS;AAAA,IACT,MAAM,CAAC,GAAG;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EACA,MAAM;AAAA,IACJ,SAAS;AAAA,IACT,MAAM,CAAC,GAAG;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EACA,QAAQ;AAAA,IACN,SAAS;AAAA,IACT,MAAM,CAAC;AAAA,IACP,MAAM;AAAA,EACR;AAAA,EACA,KAAK;AAAA,IACH,SAAS;AAAA,IACT,MAAM,CAAC,GAAG;AAAA,IACV,MAAM;AAAA,EACR;AACF;AAEA,eAAsB,yBAA4C;AAChE,QAAM,YAAsB,CAAC;AAE7B,aAAW,CAAC,MAAM,MAAM,KAAK,OAAO,QAAQ,OAAO,GAAG;AACpD,QAAI;AACF,YAAMC,OAAM,SAAS,CAAC,OAAO,OAAO,CAAC;AACrC,gBAAU,KAAK,IAAc;AAAA,IAC/B,QAAQ;AAAA,IAER;AAAA,EACF;AAEA,SAAO;AACT;AAEA,eAAsB,aACpB,UACA,QACA,MAAc,QAAQ,IAAI,GACX;AACf,QAAM,WAAW,YAAY,UAAU,GAAG;AAC1C,QAAM,SAAS,QAAQ,MAAM;AAE7B,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI,MAAM,mBAAmB,MAAM,EAAE;AAAA,EAC7C;AAGA,MAAI,CAAE,MAAMC,IAAG,WAAW,QAAQ,GAAI;AACpC,UAAM,IAAI,MAAM,6BAA6B,QAAQ,EAAE;AAAA,EACzD;AAGA,QAAMD,OAAM,OAAO,SAAS,OAAO,MAAM;AAAA,IACvC,KAAK;AAAA,IACL,UAAU;AAAA,IACV,OAAO;AAAA,EACT,CAAC;AACH;AAEA,eAAsB,gBACpB,UACA,MAAc,QAAQ,IAAI,GACX;AACf,QAAM,WAAW,YAAY,UAAU,GAAG;AAG1C,MAAI,CAAE,MAAMC,IAAG,WAAW,QAAQ,GAAI;AACpC,UAAM,IAAI,MAAM,6BAA6B,QAAQ,EAAE;AAAA,EACzD;AAIA,QAAM,QAAQD,OAAM,UAAU,CAAC,GAAG;AAAA,IAChC,KAAK;AAAA,IACL,OAAO;AAAA,EACT,CAAC;AAGD,QAAM;AACR;AAIA,IAAM,sBAAsB;AAAA,EAC1B;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AACF;AAEA,IAAM,uBAAuB;AAAA,EAC3B;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AACF;AAEA,eAAsB,kBACpB,WACA,WACmB;AACnB,QAAM,SAAmB,CAAC;AAG1B,aAAW,OAAO,qBAAqB;AACrC,UAAM,aAAaE,MAAK,KAAK,WAAW,GAAG;AAC3C,UAAM,aAAaA,MAAK,KAAK,WAAW,GAAG;AAE3C,QAAI,MAAMD,IAAG,WAAW,UAAU,GAAG;AACnC,YAAMA,IAAG,KAAK,YAAY,YAAY,EAAE,WAAW,MAAM,CAAC;AAC1D,aAAO,KAAK,GAAG;AAAA,IACjB;AAAA,EACF;AAGA,aAAW,QAAQ,sBAAsB;AACvC,UAAM,aAAaC,MAAK,KAAK,WAAW,IAAI;AAC5C,UAAM,aAAaA,MAAK,KAAK,WAAW,IAAI;AAE5C,QAAI,MAAMD,IAAG,WAAW,UAAU,GAAG;AACnC,YAAMA,IAAG,KAAK,YAAY,YAAY,EAAE,WAAW,MAAM,CAAC;AAC1D,aAAO,KAAK,IAAI;AAAA,IAClB;AAAA,EACF;AAEA,SAAO;AACT;AAEO,SAAS,cAAc,QAAwB;AACpD,SAAO,QAAQ,MAAM,GAAG,QAAQ;AAClC;AAEO,SAAS,sBAAgC;AAC9C,SAAO,OAAO,KAAK,OAAO;AAC5B;;;AF7HA,eAAsB,MACpB,QACA,MACA,SACe;AACf,QAAM,MAAM,QAAQ,IAAI;AACxB,QAAM,WAAW,QAAQ,OAAO,QAAQ,OAAO,GAAG;AAElD,QAAM,UAAUE,KAAI,kBAAkB,QAAQ,MAAM,EAAE,MAAM;AAE5D,MAAI;AACF,UAAM,SAAS,MAAM,WAAW,GAAG;AAGnC,QAAI,OAAO,MAAM,QAAQ,GAAG;AAC1B,cAAQ,KAAK,SAAS,QAAQ,kBAAkB;AAChD,cAAQ,IAAIC,OAAM,KAAK,mBAAmB,QAAQ,oBAAoB,CAAC;AACvE,cAAQ,KAAK,CAAC;AAAA,IAChB;AAGA,UAAM,cAAc,MAAM,aAAa,QAAQ,OAAO,IAAI;AAC1D,UAAM,eAAe,MAAM,mBAAmB,QAAQ,OAAO,IAAI;AACjE,UAAM,eAAe,QAAQ,OAAQ,CAAC,eAAe,CAAC;AAEtD,QAAI,CAAC,eAAe,gBAAgB,CAAC,QAAQ,KAAK;AAChD,cAAQ,OAAO,oBAAoB,MAAM;AACzC,YAAM,YAAY,QAAQ,OAAO,IAAI;AAAA,IACvC;AAGA,YAAQ,OAAO,0BAA0B,MAAM;AAC/C,UAAM,WAAW,YAAY,UAAU,GAAG;AAE1C,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,QACE,cAAc;AAAA,QACd,YAAY,QAAQ;AAAA,MACtB;AAAA,MACA,OAAO;AAAA,IACT;AAGA,YAAQ,OAAO;AACf,UAAM,gBAAgB,MAAM,kBAAkB,OAAO,MAAM,QAAQ;AACnE,QAAI,cAAc,SAAS,GAAG;AAC5B,cAAQ,OAAO,WAAW,cAAc,KAAK,IAAI,CAAC;AAAA,IACpD;AAGA,UAAM,gBAAgB,QAAQ,YAAY;AAC1C,QAAI,eAAe;AACjB,cAAQ,OAAO;AAGf,UAAI,aAA4B;AAChC,iBAAW,CAAC,cAAc,IAAI,KAAK,OAAO,QAAQ,OAAO,KAAK,GAAG;AAC/D,YAAI,MAAM,eAAe,KAAK,IAAI,GAAG;AACnC,uBAAa;AACb;AAAA,QACF;AAAA,MACF;AAEA,YAAM,UAAU,MAAM,qBAAqB,QAAQ;AAEnD,UAAI,YAAY,QAAQ;AAEtB,gBAAQ,OAAO;AACf,cAAM,oBAAoB,SAAS,UAAU;AAAA,UAC3C,gBAAgB;AAAA,UAChB,UAAU;AAAA,QACZ,CAAC;AAAA,MACH,WAAW,YAAY;AAErB,cAAM,iBAAiB,OAAO,MAAM,UAAU,EAAE;AAChD,cAAM,aAAa,MAAM,sBAAsB,gBAAgB,QAAQ;AAEvE,YAAI,YAAY;AACd,kBAAQ,OAAO,iCAAiC,UAAU;AAC1D,gBAAM,mBAAmB,gBAAgB,QAAQ;AAAA,QACnD,OAAO;AACL,kBAAQ,OAAO;AACf,gBAAM,oBAAoB,SAAS,QAAQ;AAAA,QAC7C;AAAA,MACF,OAAO;AAEL,gBAAQ,OAAO;AACf,cAAM,oBAAoB,SAAS,QAAQ;AAAA,MAC7C;AAAA,IACF;AAGA,UAAM,aAAa,CAAC,OAAO;AAAA,MACzB,GAAG;AAAA,MACH,OAAO;AAAA,QACL,GAAG,EAAE;AAAA,QACL,CAAC,QAAQ,GAAG;AAAA,UACV;AAAA,UACA,MAAM;AAAA,UACN,UAAS,oBAAI,KAAK,GAAE,YAAY;AAAA,QAClC;AAAA,MACF;AAAA,IACF,IAAI,GAAG;AAGP,QAAI,QAAQ,QAAQ;AAClB,YAAM,kBAAkB,UAAU,GAAG;AACrC,YAAM,aAAa,CAAC,OAAO;AAAA,QACzB,GAAG;AAAA,QACH,SAAS;AAAA,MACX,IAAI,GAAG;AAAA,IACT;AAEA,YAAQ,QAAQ,iBAAiB,QAAQ,GAAG;AAE5C,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAIA,OAAM,MAAM,eAAe,CAAC;AACxC,YAAQ,IAAIA,OAAM,KAAK,aAAa,QAAQ,EAAE,CAAC;AAC/C,YAAQ,IAAIA,OAAM,KAAK,aAAa,MAAM,EAAE,CAAC;AAC7C,YAAQ,IAAIA,OAAM,KAAK,aAAa,QAAQ,EAAE,CAAC;AAC/C,YAAQ,IAAI,EAAE;AAEd,QAAI,cAAc,SAAS,GAAG;AAC5B,cAAQ,IAAIA,OAAM,KAAK,iBAAiB,CAAC;AACzC,cAAQ,IAAIA,OAAM,KAAK,KAAK,cAAc,KAAK,IAAI,CAAC,EAAE,CAAC;AACvD,cAAQ,IAAI,EAAE;AAAA,IAChB;AAEA,QAAI,QAAQ,QAAQ;AAClB,cAAQ,IAAIA,OAAM,KAAK,gBAAgB,QAAQ,GAAG,CAAC;AAAA,IACrD,OAAO;AACL,cAAQ,IAAIA,OAAM,KAAK,aAAa,CAAC;AACrC,cAAQ,IAAIA,OAAM,KAAK,gBAAgB,QAAQ,gCAAgC,CAAC;AAChF,cAAQ,IAAIA,OAAM,KAAK,iBAAiB,QAAQ,kCAAkC,CAAC;AACnF,cAAQ,IAAIA,OAAM,KAAK,gBAAgB,QAAQ,gCAAgC,CAAC;AAAA,IAClF;AAAA,EACF,SAAS,OAAO;AACd,YAAQ,KAAK,sBAAsB;AACnC,YAAQ,MAAMA,OAAM,IAAI,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,CAAC;AAC/E,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;;;AG1KA,OAAOC,YAAW;;;ACAlB,SAAS,SAAAC,cAAqC;AAC9C,OAAO,gBAAgB;AACvB,OAAO,cAAc;AAKrB,IAAM,mBAAmD,oBAAI,IAAI;AAEjE,eAAsB,kBAAkB,YAAoB,KAAuB;AACjF,SAAO,WAAW,SAAS;AAC7B;AAEA,eAAsB,aACpB,UACA,MACA,MAAc,QAAQ,IAAI,GACJ;AACtB,QAAM,SAAS,MAAM,WAAW,GAAG;AACnC,QAAM,OAAO,OAAO,MAAM,QAAQ;AAElC,MAAI,CAAC,MAAM;AACT,UAAM,IAAI,MAAM,SAAS,QAAQ,aAAa;AAAA,EAChD;AAGA,MAAI,OAAO,SAAS,QAAQ,GAAG;AAC7B,UAAM,IAAI;AAAA,MACR,gBAAgB,QAAQ,gCAAgC,OAAO,SAAS,QAAQ,EAAE,IAAI;AAAA,IACxF;AAAA,EACF;AAEA,QAAM,WAAW,YAAY,UAAU,GAAG;AAC1C,QAAM,cAAc,kBAAkB,OAAO,SAAS,EAAE;AACxD,QAAM,OAAO,MAAM,kBAAkB,WAAW;AAEhD,MAAI;AACJ,MAAI;AAEJ,MAAI,SAAS,OAAO;AAClB,UAAM,SAAS,MAAM,cAAc,QAAQ;AAC3C,UAAM,QAAQ,OAAO,MAAM,GAAG;AAC9B,cAAU,MAAM,CAAC;AACjB,WAAO,CAAC,GAAG,MAAM,MAAM,CAAC,GAAG,UAAU,OAAO,IAAI,CAAC;AAAA,EACnD,OAAO;AAEL,UAAM,WAAW,MAAM,gBAAgB,QAAQ;AAC/C,UAAM,aAAa,SAAS,MAAM,GAAG;AACrC,UAAMC,OAAM,WAAW,CAAC,GAAG,WAAW,MAAM,CAAC,GAAG;AAAA,MAC9C,KAAK;AAAA,MACL,OAAO;AAAA,IACT,CAAC;AAED,UAAM,WAAW,MAAM,gBAAgB,QAAQ;AAC/C,UAAM,aAAa,SAAS,MAAM,GAAG;AACrC,cAAU,WAAW,CAAC;AACtB,WAAO,CAAC,GAAG,WAAW,MAAM,CAAC,GAAG,UAAU,OAAO,IAAI,CAAC;AAAA,EACxD;AAGA,QAAM,QAAQA,OAAM,SAAS,MAAM;AAAA,IACjC,KAAK;AAAA,IACL,OAAO;AAAA,IACP,UAAU;AAAA,EACZ,CAAC;AAGD,QAAM,MAAM,MAAM;AAEhB,mBAAe,UAAU,GAAG,EAAE,MAAM,MAAM;AAAA,IAAC,CAAC;AAAA,EAC9C,CAAC;AAED,QAAM,MAAM,MAAM;AAClB,mBAAiB,IAAI,UAAU,KAAK;AAEpC,QAAM,cAA2B;AAAA,IAC/B;AAAA,IACA;AAAA,IACA;AAAA,IACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,EACpC;AAGA,QAAM,aAAa,CAAC,OAAO;AAAA,IACzB,GAAG;AAAA,IACH,UAAU;AAAA,MACR,GAAG,EAAE;AAAA,MACL,CAAC,QAAQ,GAAG;AAAA,IACd;AAAA,EACF,IAAI,GAAG;AAEP,SAAO;AACT;AAEA,eAAsB,YACpB,UACA,MAAc,QAAQ,IAAI,GACX;AACf,QAAM,SAAS,MAAM,WAAW,GAAG;AACnC,QAAMC,WAAU,OAAO,SAAS,QAAQ;AAExC,MAAI,CAACA,UAAS;AACZ,UAAM,IAAI,MAAM,2BAA2B,QAAQ,GAAG;AAAA,EACxD;AAGA,QAAM,IAAI,QAAc,CAAC,SAAS,WAAW;AAC3C,aAASA,SAAQ,KAAK,WAAW,CAAC,QAAQ;AACxC,UAAI,KAAK;AAEP,gBAAQ;AAAA,MACV,OAAO;AACL,gBAAQ;AAAA,MACV;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AAED,QAAM,eAAe,UAAU,GAAG;AACpC;AAEA,eAAsB,gBAAgB,MAAc,QAAQ,IAAI,GAAkB;AAChF,QAAM,SAAS,MAAM,WAAW,GAAG;AAEnC,aAAW,YAAY,OAAO,KAAK,OAAO,QAAQ,GAAG;AACnD,QAAI;AACF,YAAM,YAAY,UAAU,GAAG;AAAA,IACjC,QAAQ;AAAA,IAER;AAAA,EACF;AACF;AAEA,eAAe,eACb,UACA,MAAc,QAAQ,IAAI,GACX;AACf,mBAAiB,OAAO,QAAQ;AAEhC,QAAM,aAAa,CAAC,MAAM;AACxB,UAAM,EAAE,CAAC,QAAQ,GAAG,GAAG,GAAG,kBAAkB,IAAI,EAAE;AAClD,WAAO;AAAA,MACL,GAAG;AAAA,MACH,UAAU;AAAA,IACZ;AAAA,EACF,GAAG,GAAG;AACR;AAEA,eAAsB,mBACpB,MAAc,QAAQ,IAAI,GACY;AACtC,QAAM,SAAS,MAAM,WAAW,GAAG;AACnC,SAAO,OAAO;AAChB;AAEA,eAAsB,iBACpB,UACA,MAAc,QAAQ,IAAI,GACR;AAClB,QAAM,SAAS,MAAM,WAAW,GAAG;AACnC,QAAMA,WAAU,OAAO,SAAS,QAAQ;AAExC,MAAI,CAACA,UAAS;AACZ,WAAO;AAAA,EACT;AAGA,MAAI;AACF,YAAQ,KAAKA,SAAQ,KAAK,CAAC;AAC3B,WAAO;AAAA,EACT,QAAQ;AAEN,UAAM,eAAe,UAAU,GAAG;AAClC,WAAO;AAAA,EACT;AACF;;;ADzKA,eAAsB,OAAsB;AAC1C,QAAM,MAAM,QAAQ,IAAI;AAExB,MAAI;AACF,UAAM,SAAS,MAAM,WAAW,GAAG;AACnC,UAAM,cAAc,MAAM,mBAAmB,GAAG;AAChD,UAAM,WAAW,MAAM,mBAAmB,GAAG;AAE7C,UAAM,QAAQ,OAAO,QAAQ,OAAO,KAAK;AAEzC,QAAI,MAAM,WAAW,GAAG;AACtB,cAAQ,IAAIC,OAAM,OAAO,wBAAwB,CAAC;AAClD,cAAQ,IAAIA,OAAM,KAAK,2CAA2C,CAAC;AACnE;AAAA,IACF;AAEA,YAAQ,IAAIA,OAAM,KAAK,kBAAkB,CAAC;AAE1C,UAAM,aAAa,KAAK,IAAI,GAAG,MAAM,IAAI,CAAC,CAAC,IAAI,MAAM,KAAK,MAAM,CAAC;AACjE,UAAM,eAAe,KAAK,IAAI,GAAG,MAAM,IAAI,CAAC,CAAC,EAAE,IAAI,MAAM,KAAK,OAAO,MAAM,CAAC;AAE5E,eAAW,CAAC,MAAM,IAAI,KAAK,OAAO;AAChC,YAAM,YAAY,SAAS;AAC3B,YAAMC,WAAU,SAAS,IAAI;AAC7B,YAAM,YAAYA,WAAU,MAAM,iBAAiB,MAAM,GAAG,IAAI;AAEhE,YAAM,SAAS,YAAYD,OAAM,MAAM,SAAI,IAAI;AAC/C,YAAM,UAAU,YACZA,OAAM,MAAM,KAAK,OAAO,UAAU,CAAC,IACnCA,OAAM,MAAM,KAAK,OAAO,UAAU,CAAC;AACvC,YAAM,YAAYA,OAAM,KAAK,KAAK,OAAO,OAAO,YAAY,CAAC;AAE7D,UAAI,YAAY;AAChB,UAAI,aAAaC,UAAS;AACxB,oBAAYD,OAAM,KAAK,cAAcC,SAAQ,IAAI,GAAG;AAAA,MACtD;AAEA,cAAQ,IAAI,GAAG,MAAM,GAAG,OAAO,KAAK,SAAS,GAAG,SAAS,EAAE;AAAA,IAC7D;AAEA,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAID,OAAM,KAAK,oBAAoB,OAAO,cAAc,EAAE,CAAC;AACnE,YAAQ,IAAIA,OAAM,KAAK,cAAc,OAAO,SAAS,EAAE,CAAC;AACxD,YAAQ,IAAI,EAAE;AAAA,EAChB,SAAS,OAAO;AACd,YAAQ,MAAMA,OAAM,IAAI,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,CAAC;AAC/E,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;;;AErDA,OAAOE,YAAW;AAClB,OAAOC,UAAS;AAIhB,eAAsB,KAAK,MAA6B;AACtD,QAAM,MAAM,QAAQ,IAAI;AACxB,QAAM,UAAUC,KAAI,iBAAiB,IAAI,MAAM,EAAE,MAAM;AAEvD,MAAI;AACF,UAAM,SAAS,MAAM,WAAW,GAAG;AAGnC,QAAI,CAAC,OAAO,MAAM,IAAI,GAAG;AACvB,cAAQ,KAAK,SAAS,IAAI,aAAa;AACvC,cAAQ,IAAI,EAAE;AACd,cAAQ,IAAIC,OAAM,KAAK,kBAAkB,CAAC;AAC1C,iBAAW,YAAY,OAAO,KAAK,OAAO,KAAK,GAAG;AAChD,gBAAQ,IAAIA,OAAM,KAAK,OAAO,QAAQ,EAAE,CAAC;AAAA,MAC3C;AACA,cAAQ,KAAK,CAAC;AAAA,IAChB;AAEA,UAAM,cAAc,MAAM,mBAAmB,GAAG;AAChD,QAAI,gBAAgB,MAAM;AACxB,cAAQ,KAAK,eAAe,IAAI,GAAG;AACnC;AAAA,IACF;AAGA,UAAM,kBAAkB,MAAM,GAAG;AAGjC,UAAM,aAAa,CAAC,OAAO;AAAA,MACzB,GAAG;AAAA,MACH,SAAS;AAAA,IACX,IAAI,GAAG;AAEP,UAAM,OAAO,OAAO,MAAM,IAAI;AAC9B,YAAQ,QAAQ,gBAAgB,IAAI,GAAG;AAEvC,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAIA,OAAM,KAAK,aAAa,KAAK,MAAM,EAAE,CAAC;AAClD,YAAQ,IAAIA,OAAM,KAAK,aAAa,KAAK,IAAI,EAAE,CAAC;AAChD,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAIA,OAAM,KAAK,gDAAgD,CAAC;AAAA,EAC1E,SAAS,OAAO;AACd,YAAQ,KAAK,uBAAuB;AACpC,YAAQ,MAAMA,OAAM,IAAI,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,CAAC;AAC/E,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;;;ACnDA,OAAOC,YAAW;AAClB,OAAOC,UAAS;AAChB,OAAOC,WAAU;AACjB,OAAOC,SAAQ;AAUf,eAAsB,OAAO,MAAc,SAAuC;AAChF,QAAM,MAAM,QAAQ,IAAI;AACxB,QAAM,UAAUC,KAAI,cAAc,IAAI,MAAM,EAAE,MAAM;AAEpD,MAAI;AACF,UAAM,SAAS,MAAM,WAAW,GAAG;AAGnC,QAAI,CAAC,OAAO,MAAM,IAAI,GAAG;AACvB,cAAQ,KAAK,SAAS,IAAI,aAAa;AACvC,cAAQ,KAAK,CAAC;AAAA,IAChB;AAEA,UAAM,OAAO,OAAO,MAAM,IAAI;AAI9B,UAAM,WAAW,YAAY,GAAG;AAChC,UAAM,iBAAiB,KAAK,KAAK,WAAW,QAAQ;AAEpD,QAAI,CAAC,gBAAgB;AACnB,cAAQ,KAAK,kBAAkB,IAAI,8BAA8B;AACjE,cAAQ,IAAIC,OAAM,KAAK,oDAAoD,CAAC;AAC5E,cAAQ,IAAIA,OAAM,KAAK,2DAA2D,CAAC;AACnF,cAAQ,KAAK,CAAC;AAAA,IAChB;AAGA,UAAM,cAAc,MAAM,mBAAmB,GAAG;AAChD,UAAM,YAAY,gBAAgB;AAElC,QAAI,aAAa,OAAO,KAAK,OAAO,KAAK,EAAE,WAAW,GAAG;AACvD,cAAQ,KAAK,0CAA0C;AACvD,cAAQ,IAAIA,OAAM,KAAK,gCAAgC,CAAC;AACxD,cAAQ,KAAK,CAAC;AAAA,IAChB;AAGA,QAAI,MAAM,iBAAiB,MAAM,GAAG,GAAG;AACrC,cAAQ,OAAO;AACf,YAAM,YAAY,MAAM,GAAG;AAAA,IAC7B;AAGA,YAAQ,OAAO;AACf,UAAM,eAAe,KAAK,MAAM,EAAE,OAAO,QAAQ,MAAM,GAAG,OAAO,IAAI;AAGrE,UAAM,aAAa,CAAC,MAAM;AACxB,YAAM,EAAE,CAAC,IAAI,GAAG,GAAG,GAAG,eAAe,IAAI,EAAE;AAC3C,aAAO;AAAA,QACL,GAAG;AAAA,QACH,OAAO;AAAA,QACP,SAAS,EAAE,YAAY,OAAO,OAAO,EAAE;AAAA,MACzC;AAAA,IACF,GAAG,GAAG;AAGN,QAAI,WAAW;AACb,YAAM,iBAAiB,OAAO,KAAK,OAAO,KAAK,EAAE,OAAO,CAAC,MAAM,MAAM,IAAI;AACzE,UAAI,eAAe,SAAS,GAAG;AAC7B,cAAM,aAAa,eAAe,CAAC;AACnC,cAAM,cAAc,OAAO,MAAM,UAAU,EAAE;AAG7C,cAAM,kBAAkBC,MAAK,KAAK,KAAK,SAAS;AAEhD,YAAI;AACF,gBAAMC,IAAG,MAAM,eAAe;AAC9B,gBAAMA,IAAG,OAAO,eAAe;AAAA,QACjC,QAAQ;AAAA,QAER;AAEA,cAAM,eAAeD,MAAK,SAAS,KAAK,WAAW,KAAK;AACxD,cAAMC,IAAG,QAAQ,cAAc,eAAe;AAE9C,cAAM,aAAa,CAAC,OAAO;AAAA,UACzB,GAAG;AAAA,UACH,SAAS;AAAA,QACX,IAAI,GAAG;AACP,gBAAQ,QAAQ,aAAa,IAAI,mBAAmB,UAAU,GAAG;AAAA,MACnE,OAAO;AACL,cAAM,kBAAkB,GAAG;AAC3B,gBAAQ,QAAQ,aAAa,IAAI,GAAG;AAAA,MACtC;AAAA,IACF,OAAO;AACL,cAAQ,QAAQ,aAAa,IAAI,GAAG;AAAA,IACtC;AAEA,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAIF,OAAM,KAAK,aAAa,KAAK,MAAM,EAAE,CAAC;AAClD,YAAQ,IAAIA,OAAM,KAAK,aAAa,KAAK,IAAI,YAAY,CAAC;AAAA,EAC5D,SAAS,OAAO;AACd,YAAQ,KAAK,uBAAuB;AACpC,YAAQ,MAAMA,OAAM,IAAI,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,CAAC;AAE/E,QAAI,CAAC,QAAQ,OAAO;AAClB,cAAQ,IAAI,EAAE;AACd,cAAQ,IAAIA,OAAM,OAAO,mCAAmC,CAAC;AAAA,IAC/D;AACA,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;;;ACpHA,OAAOG,YAAW;AAClB,OAAOC,UAAS;AAehB,eAAsB,QACpB,QACA,MACA,SACe;AACf,QAAM,MAAM,QAAQ,IAAI;AAGxB,MAAI,WAAW,QAAQ;AACrB,QAAI,MAAM;AACR,YAAM,SAAS,MAAM,GAAG;AAAA,IAC1B,OAAO;AACL,YAAM,QAAQ,GAAG;AAAA,IACnB;AACA;AAAA,EACF;AAGA,QAAM,WAAW;AACjB,QAAM,UAAU,UAAU,SAAS,GAAG;AACxC;AAEA,eAAe,UACb,MACA,SACA,KACe;AACf,QAAM,UAAUC,KAAI,yBAAyB,IAAI,MAAM,EAAE,MAAM;AAE/D,MAAI;AACF,UAAM,SAAS,MAAM,WAAW,GAAG;AAEnC,QAAI,CAAC,OAAO,MAAM,IAAI,GAAG;AACvB,cAAQ,KAAK,SAAS,IAAI,aAAa;AACvC,cAAQ,KAAK,CAAC;AAAA,IAChB;AAGA,QAAI,MAAM,iBAAiB,MAAM,GAAG,GAAG;AACrC,YAAMC,WAAU,OAAO,SAAS,IAAI;AACpC,cAAQ,KAAK,gBAAgB,IAAI,gCAAgCA,SAAQ,IAAI,EAAE;AAC/E,cAAQ,IAAI,EAAE;AACd,cAAQ,IAAIC,OAAM,KAAK,sBAAsBD,SAAQ,IAAI,EAAE,CAAC;AAC5D;AAAA,IACF;AAEA,UAAM,OAAO,QAAQ,QAAQ,UAAU;AACvC,YAAQ,OAAO,SAAS,UAAU,oCAAoC;AAEtE,UAAM,cAAc,MAAM,aAAmB,MAAM,MAAM,GAAG;AAE5D,YAAQ,QAAQ,wBAAwB,IAAI,GAAG;AAE/C,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAIC,OAAM,MAAM,iBAAiB,CAAC;AAC1C,YAAQ,IAAIA,OAAM,KAAK,sBAAsB,YAAY,IAAI,EAAE,CAAC;AAChE,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAIA,OAAM,KAAK,SAAS,IAAI,EAAE,CAAC;AACvC,YAAQ,IAAIA,OAAM,KAAK,QAAQ,YAAY,GAAG,EAAE,CAAC;AACjD,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAIA,OAAM,OAAO,iCAAiC,CAAC;AAAA,EAC7D,SAAS,OAAO;AACd,YAAQ,KAAK,yBAAyB;AACtC,YAAQ,MAAMA,OAAM,IAAI,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,CAAC;AAC/E,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;AAEA,eAAe,SAAS,MAAc,KAA4B;AAChE,QAAM,UAAUF,KAAI,yBAAyB,IAAI,MAAM,EAAE,MAAM;AAE/D,MAAI;AACF,QAAI,CAAE,MAAM,iBAAiB,MAAM,GAAG,GAAI;AACxC,cAAQ,KAAK,2BAA2B,IAAI,GAAG;AAC/C;AAAA,IACF;AAEA,UAAM,YAAkB,MAAM,GAAG;AACjC,YAAQ,QAAQ,wBAAwB,IAAI,GAAG;AAAA,EACjD,SAAS,OAAO;AACd,YAAQ,KAAK,wBAAwB;AACrC,YAAQ,MAAME,OAAM,IAAI,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,CAAC;AAC/E,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;AAEA,eAAe,QAAQ,KAA4B;AACjD,QAAM,UAAUF,KAAI,0BAA0B,EAAE,MAAM;AAEtD,MAAI;AACF,UAAM,SAAS,MAAM,WAAW,GAAG;AACnC,UAAM,eAAe,OAAO,KAAK,OAAO,QAAQ,EAAE;AAElD,QAAI,iBAAiB,GAAG;AACtB,cAAQ,KAAK,qBAAqB;AAClC;AAAA,IACF;AAEA,UAAM,gBAAgB,GAAG;AACzB,YAAQ,QAAQ,WAAW,YAAY,aAAa;AAAA,EACtD,SAAS,OAAO;AACd,YAAQ,KAAK,yBAAyB;AACtC,YAAQ,MAAME,OAAM,IAAI,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,CAAC;AAC/E,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;;;ACzHA,OAAOC,YAAW;AAKlB,eAAsB,SAAwB;AAC5C,QAAM,MAAM,QAAQ,IAAI;AAExB,MAAI;AACF,UAAM,SAAS,MAAM,WAAW,GAAG;AACnC,UAAM,cAAc,MAAM,mBAAmB,GAAG;AAChD,UAAM,WAAW,MAAM,mBAAmB,GAAG;AAE7C,YAAQ,IAAIC,OAAM,KAAK,kBAAkB,CAAC;AAG1C,YAAQ,IAAIA,OAAM,MAAM,eAAe,CAAC;AACxC,QAAI,eAAe,OAAO,MAAM,WAAW,GAAG;AAC5C,YAAM,OAAO,OAAO,MAAM,WAAW;AACrC,cAAQ,IAAIA,OAAM,MAAM,KAAK,WAAW,EAAE,CAAC;AAC3C,cAAQ,IAAIA,OAAM,KAAK,aAAa,KAAK,MAAM,EAAE,CAAC;AAClD,cAAQ,IAAIA,OAAM,KAAK,mBAAmB,CAAC;AAAA,IAC7C,OAAO;AACL,cAAQ,IAAIA,OAAM,OAAO,iBAAiB,CAAC;AAAA,IAC7C;AACA,YAAQ,IAAI,EAAE;AAGd,YAAQ,IAAIA,OAAM,MAAM,mBAAmB,CAAC;AAC5C,UAAM,iBAAiB,OAAO,QAAQ,QAAQ;AAE9C,QAAI,eAAe,WAAW,GAAG;AAC/B,cAAQ,IAAIA,OAAM,KAAK,uBAAuB,CAAC;AAAA,IACjD,OAAO;AACL,iBAAW,CAAC,MAAMC,QAAO,KAAK,gBAAgB;AAC5C,cAAM,UAAU,MAAM,iBAAiB,MAAM,GAAG;AAChD,YAAI,SAAS;AACX,kBAAQ;AAAA,YACND,OAAM,KAAK,KAAK,IAAI,EAAE,IACtBA,OAAM,KAAK,4BAAuBC,SAAQ,IAAI,EAAE,IAChDD,OAAM,KAAK,KAAKC,SAAQ,IAAI,GAAG;AAAA,UACjC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,YAAQ,IAAI,EAAE;AAGd,UAAM,YAAY,OAAO,KAAK,OAAO,KAAK,EAAE;AAC5C,UAAM,eAAe,eAAe;AAAA,MAClC,OAAO,CAAC,IAAI,MAAM,MAAM,iBAAiB,MAAM,GAAG;AAAA,IACpD,EAAE;AAEF,YAAQ,IAAID,OAAM,MAAM,UAAU,CAAC;AACnC,YAAQ,IAAIA,OAAM,KAAK,YAAY,SAAS,EAAE,CAAC;AAC/C,YAAQ,IAAIA,OAAM,KAAK,uBAAuB,YAAY,EAAE,CAAC;AAC7D,YAAQ,IAAIA,OAAM,KAAK,sBAAsB,OAAO,cAAc,EAAE,CAAC;AACrE,YAAQ,IAAIA,OAAM,KAAK,gBAAgB,OAAO,SAAS,EAAE,CAAC;AAC1D,YAAQ,IAAI,EAAE;AAAA,EAChB,SAAS,OAAO;AACd,YAAQ,MAAMA,OAAM,IAAI,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,CAAC;AAC/E,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;;;AC/DA,OAAOE,YAAW;AAClB,OAAOC,UAAS;AAchB,eAAsB,KAAK,MAAc,SAAqC;AAC5E,QAAM,MAAM,QAAQ,IAAI;AAExB,MAAI;AACF,UAAM,SAAS,MAAM,WAAW,GAAG;AAGnC,QAAI,CAAC,OAAO,MAAM,IAAI,GAAG;AACvB,cAAQ,IAAIC,OAAM,IAAI,SAAS,IAAI,aAAa,CAAC;AACjD,cAAQ,IAAI,EAAE;AACd,cAAQ,IAAIA,OAAM,KAAK,kBAAkB,CAAC;AAC1C,iBAAW,YAAY,OAAO,KAAK,OAAO,KAAK,GAAG;AAChD,gBAAQ,IAAIA,OAAM,KAAK,OAAO,QAAQ,EAAE,CAAC;AAAA,MAC3C;AACA,cAAQ,KAAK,CAAC;AAAA,IAChB;AAGA,QAAI;AAEJ,QAAI,QAAQ,QAAQ;AAClB,YAAM,YAAY,oBAAoB;AACtC,UAAI,CAAC,UAAU,SAAS,QAAQ,MAAgB,GAAG;AACjD,gBAAQ,IAAIA,OAAM,IAAI,mBAAmB,QAAQ,MAAM,EAAE,CAAC;AAC1D,gBAAQ,IAAIA,OAAM,KAAK,cAAc,UAAU,KAAK,IAAI,CAAC,EAAE,CAAC;AAC5D,gBAAQ,KAAK,CAAC;AAAA,MAChB;AACA,eAAS,QAAQ;AAAA,IACnB,OAAO;AAEL,YAAM,YAAY,MAAM,uBAAuB;AAE/C,UAAI,UAAU,WAAW,GAAG;AAC1B,gBAAQ,IAAIA,OAAM,IAAI,4BAA4B,CAAC;AACnD,gBAAQ,IAAIA,OAAM,KAAK,qDAAqD,CAAC;AAC7E,gBAAQ,KAAK,CAAC;AAAA,MAChB;AAGA,YAAM,kBAA4B,CAAC,UAAU,UAAU,QAAQ,KAAK;AACpE,eAAS,gBAAgB,KAAK,CAAC,MAAM,UAAU,SAAS,CAAC,CAAC,KAAK,UAAU,CAAC;AAAA,IAC5E;AAEA,UAAM,UAAUC,KAAI,YAAY,IAAI,QAAQ,cAAc,MAAM,CAAC,KAAK,EAAE,MAAM;AAE9E,UAAM,aAAa,MAAM,QAAQ,GAAG;AAEpC,UAAM,WAAW,YAAY,MAAM,GAAG;AACtC,YAAQ,QAAQ,WAAW,IAAI,QAAQ,cAAc,MAAM,CAAC,EAAE;AAE9D,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAID,OAAM,KAAK,WAAW,QAAQ,EAAE,CAAC;AAC7C,YAAQ,IAAIA,OAAM,KAAK,aAAa,OAAO,MAAM,IAAI,EAAE,MAAM,EAAE,CAAC;AAAA,EAClE,SAAS,OAAO;AACd,YAAQ,MAAMA,OAAM,IAAI,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,CAAC;AAC/E,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;;;ACxEA,OAAOE,YAAW;AAIlB,eAAsB,MAAM,MAA6B;AACvD,QAAM,MAAM,QAAQ,IAAI;AAExB,MAAI;AACF,UAAM,SAAS,MAAM,WAAW,GAAG;AAGnC,QAAI,CAAC,OAAO,MAAM,IAAI,GAAG;AACvB,cAAQ,IAAIC,OAAM,IAAI,SAAS,IAAI,aAAa,CAAC;AACjD,cAAQ,IAAI,EAAE;AACd,cAAQ,IAAIA,OAAM,KAAK,kBAAkB,CAAC;AAC1C,iBAAW,YAAY,OAAO,KAAK,OAAO,KAAK,GAAG;AAChD,gBAAQ,IAAIA,OAAM,KAAK,OAAO,QAAQ,EAAE,CAAC;AAAA,MAC3C;AACA,cAAQ,KAAK,CAAC;AAAA,IAChB;AAEA,UAAM,WAAW,YAAY,MAAM,GAAG;AACtC,UAAM,OAAO,OAAO,MAAM,IAAI;AAE9B,YAAQ,IAAIA,OAAM,KAAK,4BAA4B,IAAI,MAAM,CAAC;AAC9D,YAAQ,IAAIA,OAAM,KAAK,WAAW,QAAQ,EAAE,CAAC;AAC7C,YAAQ,IAAIA,OAAM,KAAK,aAAa,KAAK,MAAM,EAAE,CAAC;AAClD,YAAQ,IAAI,EAAE;AAGd,UAAM,gBAAgB,MAAM,GAAG;AAE/B,YAAQ,IAAI,EAAE;AACd,YAAQ,IAAIA,OAAM,KAAK,4BAA4B,CAAC;AAAA,EACtD,SAAS,OAAO;AACd,YAAQ,MAAMA,OAAM,IAAI,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,CAAC;AAC/E,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;;;ACpCA,eAAsB,QAAQ,MAA6B;AACzD,QAAM,MAAM,QAAQ,IAAI;AAExB,MAAI;AACF,UAAM,SAAS,MAAM,WAAW,GAAG;AAGnC,QAAI,CAAC,OAAO,MAAM,IAAI,GAAG;AACvB,cAAQ,MAAM,SAAS,IAAI,aAAa;AACxC,cAAQ,KAAK,CAAC;AAAA,IAChB;AAEA,UAAM,WAAW,YAAY,MAAM,GAAG;AAItC,YAAQ,IAAI,QAAQ;AAAA,EACtB,SAAS,OAAO;AACd,YAAQ,MAAM,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AACpE,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;;;AlBVA,QACG,KAAK,OAAO,EACZ,YAAY,qDAAqD,EACjE,QAAQ,OAAO;AAElB,QACG,QAAQ,MAAM,EACd,YAAY,wCAAwC,EACpD,OAAO,IAAI;AAEd,QACG,QAAQ,uBAAuB,EAC/B,YAAY,sCAAsC,EAClD,OAAO,aAAa,qBAAqB,EACzC,OAAO,uBAAuB,4BAA4B,EAC1D,OAAO,gBAAgB,8BAA8B,EACrD,OAAO,gBAAgB,uCAAuC,EAC9D,OAAO,KAAK;AAEf,QACG,QAAQ,aAAa,EACrB,YAAY,uCAAuC,EACnD,OAAO,IAAI;AAEd,QACG,QAAQ,MAAM,EACd,MAAM,IAAI,EACV,YAAY,6BAA6B,EACzC,OAAO,IAAI;AAEd,QACG,QAAQ,eAAe,EACvB,YAAY,mBAAmB,EAC/B,OAAO,eAAe,6CAA6C,EACnE,OAAO,MAAM;AAGhB,QACG,QAAQ,aAAa,EACrB,YAAY,qDAAqD,EACjE,OAAO,yBAAyB,oCAAoC,EACpE,OAAO,IAAI;AAEd,QACG,QAAQ,cAAc,EACtB,YAAY,wDAAwD,EACpE,OAAO,KAAK;AAEf,QACG,QAAQ,aAAa,EACrB,YAAY,sDAAsD,EAClE,OAAO,OAAO;AAGjB,QACG,QAAQ,yBAAyB,EACjC,YAAY,yDAAyD,EACrE,OAAO,aAAa,mCAAmC,EACvD,OAAO,eAAe,oCAAoC,EAC1D,OAAO,OAAO;AAEjB,QACG,QAAQ,QAAQ,EAChB,YAAY,wCAAwC,EACpD,OAAO,MAAM;AAGhB,QAAQ,YAAY,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAyB5B;AAED,QAAQ,MAAM;","names":["fs","path","fs","path","execa","fs","path","execa","fs","path","fs","path","path","fs","fs","path","chalk","ora","fs","path","path","fs","execa","fs","path","execa","fs","path","ora","chalk","chalk","execa","execa","preview","chalk","preview","chalk","ora","ora","chalk","chalk","ora","path","fs","ora","chalk","path","fs","chalk","ora","ora","preview","chalk","chalk","chalk","preview","chalk","ora","chalk","ora","chalk","chalk"]}